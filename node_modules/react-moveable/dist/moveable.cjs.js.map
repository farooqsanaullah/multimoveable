{"version":3,"file":"moveable.cjs.js","sources":["../src/react-moveable/consts.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.ts","../src/react-moveable/CustomDragger.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/consts.ts","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"sourcesContent":["import { prefixCSS } from \"framework-utils\";\nimport getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport const agent = getAgent();\nexport const isWebkit\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = prefixCSS(PREFIX, `\n{\n\tposition: fixed;\n\twidth: 0;\n\theight: 0;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 3000;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n\ttop: 0;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    z-index: 10;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tbackground: #4af;\n\ttransform-origin: 0px 0.5px;\n}\n.line.rotation-line {\n\theight: 40px;\n\twidth: 1px;\n\ttransform-origin: 0.5px 39.5px;\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n\tcursor: alias;\n}\n.line.vertical.bold {\n    width: 2px;\n    margin-left: -1px;\n}\n.line.horizontal.bold {\n    height: 2px;\n    margin-top: -1px;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n\tmargin-left: -6px;\n\tpointer-events: none;\n}\n.direction.e, .direction.w {\n\tcursor: ew-resize;\n}\n.direction.s, .direction.n {\n\tcursor: ns-resize;\n}\n.direction.nw, .direction.se, :host.reverse .direction.ne, :host.reverse .direction.sw {\n\tcursor: nwse-resize;\n}\n.direction.ne, .direction.sw, :host.reverse .direction.nw, :host.reverse .direction.se {\n\tcursor: nesw-resize;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n${isWebkit ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`);\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\n","import { PREFIX, isWebkit } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertCSStoMatrix, convertMatrixtoCSS,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n} from \"@moveable/matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport { MoveableManagerState, Able } from \"./types\";\n\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransform(target: SVGElement | HTMLElement, isInit: true): number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: false): \"none\" | number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: boolean) {\n    const transform = getComputedStyle(target).transform!;\n\n    if (!transform || (transform === \"none\" && !isInit)) {\n        return \"none\";\n    }\n    return getTransformMatrix(transform);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = el.ownerSVGElement!.viewBox.baseVal;\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], string, number[], boolean] {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    const isSVGGraphicElement = el.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in el;\n    const originalContainer = container || document.body;\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    if (prevMatrix) {\n        container = target.parentElement;\n    }\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        const styleTransform = style.transform!;\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(styleTransform));\n\n        if (!is3d && matrix.length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d && matrix.length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n\n        let offsetLeft = (el as any).offsetLeft;\n        let offsetTop = (el as any).offsetTop;\n\n        if (isFixed) {\n            const containerRect = (container || document.documentElement).getBoundingClientRect();\n\n            offsetLeft -= containerRect.left;\n            offsetTop -= containerRect.top;\n        }\n        // svg\n        const isSVG = isUndefined(offsetLeft);\n        let hasNotOffset = isSVG;\n        let origin: number[];\n        // inner svg element\n        if (hasNotOffset && tagName !== \"svg\") {\n            origin = isWebkit\n                ? getBeforeTransformOrigin(el as SVGElement)\n                : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n            hasNotOffset = false;\n\n            if (tagName === \"g\") {\n                offsetLeft = 0;\n                offsetTop = 0;\n            } else {\n                [\n                    offsetLeft, offsetTop, origin[0], origin[1],\n                ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n            }\n        } else {\n            origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        }\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (isWebkit && !hasNotOffset && !isSVG && isStatic && position === \"relative\") {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n\n            isEnd = isEnd || isOffsetEnd;\n        }\n        matrixes.push(\n            getAbsoluteMatrix(matrix, n, origin),\n            createOriginMatrix([\n                (hasNotOffset ? el : offsetLeft - el.scrollLeft) as any,\n                (hasNotOffset ? origin : offsetTop - el.scrollTop) as any,\n            ], n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n\n    }\n    let mat = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    matrixes.reverse();\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            beforeMatrix = mat.slice();\n        }\n        if (length - 1 === i) {\n            offsetMatrix = mat.slice();\n        }\n\n        if (isObject(matrix[n - 1])) {\n            [matrix[n - 1], matrix[2 * n - 1]] =\n                getSVGOffset(\n                    matrix[n - 1] as any,\n                    endContainer,\n                    n,\n                    matrix[2 * n - 1] as any,\n                    mat,\n                    matrixes[i + 1],\n                );\n        }\n        mat = multiply(\n            mat,\n            matrix,\n            n,\n        );\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n    const transform = `${isMatrix3d ? \"matrix3d\" : \"matrix\"}(${\n        convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix)\n        })`;\n\n    return [\n        beforeMatrix, offsetMatrix, mat, targetMatrix, transform, transformOrigin, is3d,\n    ];\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = (el as SVGSVGElement).viewBox.baseVal;\n    const viewBoxWidth = viewBox.width || clientWidth;\n    const viewBoxHeight = viewBox.height || clientHeight;\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = (el as SVGSVGElement).preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n - 1],\n        scaleMatrix[2 * n - 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const svgElement = el.ownerSVGElement!;\n    const viewBox = svgElement.viewBox.baseVal;\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    const pos1 = caculatePosition(matrix, [0, 0], n);\n    const pos2 = caculatePosition(matrix, [width, 0], n);\n    const pos3 = caculatePosition(matrix, [0, height], n);\n    const pos4 = caculatePosition(matrix, [width, height], n);\n\n    return [pos1, pos2, pos3, pos4];\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el);\n    const containerRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerRect.left + container.scrollLeft;\n    const rectTop = rect.top - containerRect.top + container.scrollTop;\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n        direction,\n    ];\n}\n\nexport function getLineStyle(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const width = Math.sqrt(distX * distX + distY * distY);\n    const rad = getRad(pos1, pos2);\n\n    return {\n        transform: `translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px)`,\n    };\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (!hasOffset && !width && !height) {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n\n        return [bbox.width, bbox.height];\n    }\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getTargetInfo(\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let pos1 = [0, 0];\n    let pos2 = [0, 0];\n    let pos3 = [0, 0];\n    let pos4 = [0, 0];\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let clientRect = { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 };\n    let containerRect = { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 };\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            beforeMatrix, offsetMatrix, matrix,\n            targetMatrix,\n            targetTransform, transformOrigin, is3d,\n        ] = caculateMatrixStack(target, container!, prevMatrix, prevN);\n\n        [\n            [left, top, right, bottom],\n            origin,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , , , , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        clientRect = getClientRect(target);\n        containerRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n        );\n    }\n\n    return {\n        containerRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        width,\n        height,\n        beforeMatrix,\n        matrix,\n        targetTransform,\n        offsetMatrix,\n        targetMatrix,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n        clientRect,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    return {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos4);\n    const k3 = getOrientationDirection(pos, pos4, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos4);\n    const k5 = getOrientationDirection(pos, pos4, pos3);\n    const k6 = getOrientationDirection(pos, pos3, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: MoveableManager,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any>, U extends keyof T>(\n    moveable: MoveableManager<T>,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : {},\n): any {\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(ables: Able[], methods: Array<keyof Able>) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (able.ableGroup) {\n            if (ableGroups[name]) {\n                return false;\n            }\n            ableGroups[name] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}End`, params);\n}\n","import MoveableManager from \"./MoveableManager\";\nimport Dragger, { OnDragStart, OnDrag, OnDragEnd, OnPinchEnd } from \"@daybrush/drag\";\nimport { Able } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\n\nfunction triggerAble<T extends IObject<any>>(\n    moveable: MoveableManager<any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: OnDragStart | OnDrag | OnDragEnd | OnPinchEnd,\n) {\n    const isStart = eventType === \"Start\";\n\n    if (isStart && eventAffix.indexOf(\"Control\") > -1 && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n\n    if (isStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Array<Able<T>> = (moveable as any)[ableType];\n    const results = ables.filter((able: any) => {\n        const condition = isStart && able[conditionName];\n\n        if (able[eventName] && (!condition || condition(e.inputEvent.target, moveable))) {\n            return able[eventName](moveable, e);\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        triggerRenderStart(moveable, isGroup, e);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, e);\n    } else {\n        triggerRender(moveable, isGroup, e);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (!isStart && isUpdate) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType);\n        } else {\n            moveable.updateTarget(eventType);\n        }\n    } else if (isEnd && !isUpdate) {\n        moveable.forceUpdate();\n    }\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    target: HTMLElement | SVGElement,\n    ableType: string,\n    eventAffix: string,\n) {\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold: moveable.props.pinchThreshold,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            options[`${eventOperation}${eventType.toLowerCase()}`]\n                = (e: any) => triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n} from \"./utils\";\nimport styler from \"react-css-styler\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo } from \"./types\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport CustomDragger from \"./CustomDragger\";\n\nconst ControlBoxElement = styler(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-direction={direction} style={getLineStyle(pos1, pos2)}></div>;\n}\nexport default class MoveableManager<T = {}, U = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState<U>> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        container: null,\n        origin: true,\n        keepRatio: false,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n    };\n    public state: MoveableManagerState<U> = {\n        conatainer: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        clientRect: { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 },\n        containerRect: { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 },\n    } as any;\n    public targetAbles: Array<Able<T>> = [];\n    public controlAbles: Array<Able<T>> = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public customDragger!: CustomDragger;\n\n    public render() {\n        const { edge, parentPosition, className } = this.props;\n\n        this.checkUpdate();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, pos1, pos2, pos3, pos4, target, direction } = this.state;\n\n        return (\n            <ControlBoxElement\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\")} ${className}`} style={{\n                    position: \"absolute\",\n                    display: target ? \"block\" : \"none\",\n                    transform: `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", pos1, pos2, 0)}\n                {renderLine(edge ? \"e\" : \"\", pos2, pos4, 1)}\n                {renderLine(edge ? \"w\" : \"\", pos1, pos3, 2)}\n                {renderLine(edge ? \"s\" : \"\", pos3, pos4, 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps<T>) {\n        this.updateEvent(prevProps);\n    }\n    public componentWillUnmount() {\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement | null {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().offsetParent as HTMLElement;\n    }\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.onDragStart(e);\n        }\n    }\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = target.getBoundingClientRect();\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos4, pos3);\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const parentMoveable = this.props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        this.updateState(\n            getTargetInfo(target, container, container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps<T>) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const target = this.props.target;\n        const prevTarget = prevProps.target;\n        const dragArea = this.props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            if (dragArea) {\n                this.targetDragger = getAbleDragger(this, this.areaElement!, \"targetAbles\", \"\");\n            } else {\n                this.targetDragger = getAbleDragger(this, target!, \"targetAbles\", \"\");\n            }\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    public getRect(): RectInfo {\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        };\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = stateTarget !== target || stateContainer !== container;\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart]);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        const enabledAbles = ables.filter(able => able && props[able.name]);\n        return filterAbles(enabledAbles, [\"render\"]).map(({ render }) => render!(this, React));\n    }\n}\n","import { Client } from \"@daybrush/drag\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { PinchableProps, Able, SnappableState, OnPinchStart, OnPinch, OnPinchEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { getRad } from \"@moveable/matrix\";\n\nfunction getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    pinchStart(\n        moveable: MoveableManager<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, touches, inputEvent, targets } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        const parentRotate = getRotatiion(touches);\n\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n            const ableEvent: any = {\n                datas: datas[able.name + \"Datas\"],\n                clientX,\n                clientY,\n                inputEvent,\n                parentRotate,\n                pinchFlag: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapDirection = [0, 0];\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, scale: pinchScale, distance, touches, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentRotate = getRotatiion(touches);\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate,\n                pinchFlag: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                pinchFlag: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroup, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroup, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","import MoveableGroup from \"./MoveableGroup\";\nimport { Able } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { hasClass, IObject, isFunction } from \"@daybrush/utils\";\nimport { prefix } from \"./utils\";\n\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroup,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManager, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManager<any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\nexport function directionCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"direction\"));\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"@moveable/matrix\";\nimport MoveableManager from \"./MoveableManager\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManager<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix, is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   const nextPoses = getPosesByDirection(poses, direction);\n\n   return [\n       average(...nextPoses.map(pos => pos[0])),\n       average(...nextPoses.map(pos => pos[1])),\n   ];\n}\nexport function getPosByReverseDirection(\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\nfunction getStartPos(poses: number[][], direction: number[]) {\n    const [\n        startPos1,\n        startPos2,\n        startPos3,\n        startPos4,\n    ] = poses;\n    return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManager<any>,\n    scale: number[],\n    direction: number[],\n    dragClient?: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n\n    const dist = getDist(\n        startPos, nextMatrix, width, height, n,\n        direction,\n    );\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManager<any>,\n    width: number,\n    height: number,\n    direction: number[],\n    transformOrigin: string[],\n    dragClient?: number[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevheight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevheight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n    const dist = getDist(startPos, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { Renderer, SnappableProps, SnappableState, Guideline, SnapInfo, BoundInfo, ScalableProps } from \"../types\";\nimport { prefix, caculatePoses, getRect, getAbsolutePosesByState, getAbsolutePoses } from \"../utils\";\nimport { directionCondition } from \"../groupUtils\";\nimport { isUndefined, IObject } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection, getPosesByDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus } from \"@moveable/matrix\";\n\nfunction snapStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n        return;\n    }\n\n    const {\n        containerRect: {\n            width: containerWidth,\n            height: containerHeight,\n            top: containerTop,\n            left: containerLeft,\n        },\n        clientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        left: targetLeft,\n        top: targetTop,\n    } = state;\n\n    const distLeft = targetLeft - (clientLeft - containerLeft);\n    const distTop = targetTop - (clientTop - containerTop);\n    const guidelines: Guideline[] = [];\n\n    horizontalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"horizontal\", pos: [0, pos], size: containerWidth });\n    });\n    verticalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"vertical\", pos: [pos, 0], size: containerHeight });\n    });\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const { top, left, width, height } = rect;\n        const elementTop = top - containerTop;\n        const elementBottom = elementTop + height;\n        const elementLeft = left - containerLeft;\n        const elementRight = elementLeft + width;\n\n        guidelines.push({ type: \"vertical\", element: el, pos: [elementLeft + distLeft, elementTop], size: height });\n        guidelines.push({ type: \"vertical\", element: el, pos: [elementRight + distLeft, elementTop], size: height });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [elementLeft, elementTop + distTop], size: width });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [elementLeft, elementBottom + distTop], size: width });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [(elementLeft + elementRight) / 2 + distLeft, elementTop],\n                size: height,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [elementLeft, (elementTop + elementBottom) / 2 + distTop],\n                size: width,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\nfunction checkBounds(\n    moveable: MoveableManager<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    snapThreshold?: number,\n) {\n    return {\n        vertical: checkBound(moveable, verticalPoses, true, snapThreshold),\n        horizontal: checkBound(moveable, horizontalPoses, false, snapThreshold),\n    };\n}\nfunction checkBound(\n    moveable: MoveableManager<SnappableProps>,\n    poses: number[],\n    isVertical: boolean,\n    snapThreshold: number = 0,\n): BoundInfo {\n    const bounds = moveable.props.bounds;\n\n    if (bounds) {\n        const startPos = bounds[isVertical ? \"left\" : \"top\"];\n        const endPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n        const minPos = Math.min(...poses);\n        const maxPos = Math.max(...poses);\n\n        if (!isUndefined(startPos) && startPos + snapThreshold > minPos) {\n            return {\n                isBound: true,\n                offset: minPos - startPos,\n                pos: startPos,\n            };\n        }\n        if (!isUndefined(endPos) && endPos - snapThreshold < maxPos) {\n            return {\n                isBound: true,\n                offset: maxPos - endPos,\n                pos: endPos,\n            };\n        }\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    isSnapCenter: boolean | undefined,\n    snapThreshold: number,\n): SnapInfo {\n    if (!guidelines) {\n        return {\n            isSnap: false,\n            dist: -1,\n            offset: 0,\n            guidelines: [],\n            snapPoses: [],\n        };\n    }\n    let snapGuidelines: Guideline[] = [];\n    let snapDist = Infinity;\n    let snapOffset = 0;\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPoses = targetPoses.filter(targetPos => {\n        return guidelines.filter(guideline => {\n            const { type, pos, center } = guideline;\n\n            if ((!isSnapCenter && center) || type !== targetType) {\n                return false;\n            }\n            const offset = targetPos - pos[posType];\n            const dist = Math.abs(offset);\n\n            if (dist > snapThreshold) {\n                return false;\n            }\n            if (snapDist > dist) {\n                snapDist = dist;\n                snapGuidelines = [];\n            }\n            if (snapDist === dist) {\n                snapOffset = offset;\n                snapGuidelines.push(guideline);\n            }\n            return true;\n        }).length;\n    });\n\n    return {\n        isSnap: !!snapGuidelines.length,\n        dist: isFinite(snapDist) ? snapDist : -1,\n        offset: snapOffset,\n        guidelines: snapGuidelines,\n        snapPoses,\n    };\n}\nexport function hasGuidelines(\n    moveable: MoveableManager<any, any>,\n    ableName: string,\n): moveable is MoveableManager<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName))\n        || (!bounds && (!guidelines || !guidelines.length))\n    ) {\n        return false;\n    }\n    return true;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    isSnapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const guidelines = moveable.state.guidelines;\n    const snapThreshold = !isUndefined(customSnapThreshold)\n        ? customSnapThreshold\n        : !isUndefined(moveable.props.snapThreshold)\n            ? moveable.props.snapThreshold\n            : 5;\n\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, isSnapCenter, snapThreshold),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, isSnapCenter, snapThreshold),\n    };\n}\nexport function checkSnaps(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\nexport function getSize(x: number, y: number) {\n    return Math.sqrt(x * x + y * y);\n}\nfunction checkBoundOneWayDist(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n) {\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    if (isHorizontalBound || isVerticalBound) {\n        let isVertical!: boolean;\n\n        if (isHorizontalBound && isVerticalBound) {\n            isVertical = Math.abs(horizontalBoundOffset) < Math.abs(verticalBoundOffset);\n        } else {\n            isVertical = isVerticalBound;\n        }\n        const offset = isVertical ? verticalBoundOffset : horizontalBoundOffset;\n        return {\n            isVertical,\n            offset,\n            dist: Math.abs(offset),\n        };\n    }\n    return;\n}\nfunction solveNextDist(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    isDirectionVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        -offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return NaN;\n    }\n    const [widthDist, heightDist] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return isDirectionVertical ? heightDist : widthDist;\n}\nfunction getFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return  getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\n\nfunction checkBoundOneWayPos(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n    reversePos: number[],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    const {\n        horizontal: {\n            isSnap: isHorizontalSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isSnap: isVerticalSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    } = checkSnapPoses(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    const fixedHorizontal = reversePos[1] === pos[1];\n    const fixedVertical = reversePos[0] === pos[0];\n\n    let isVertical!: boolean;\n\n    if (!isHorizontalSnap && !isVerticalSnap) {\n        // no snap\n        return NaN;\n    } else if (isHorizontalSnap && isVerticalSnap) {\n        if (horizontalDist === 0 && fixedHorizontal) {\n            isVertical = true;\n        } else if (verticalOffset === 0 && fixedVertical) {\n            isVertical = false;\n        } else {\n            isVertical = horizontalDist > verticalDist;\n        }\n    } else {\n        isVertical = isVerticalSnap;\n    }\n    return solveNextDist(\n        reversePos, pos,\n        (isVertical ? verticalOffset : horizontalOffset),\n        isVertical,\n        isDirectionVertical,\n        datas,\n    );\n}\nexport function checkOneWayPos(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    reversePoses: number[][],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    let posOffset = 0;\n    let boundInfo!: {\n        isVertical: boolean,\n        offset: number,\n        dist: number,\n    } | undefined;\n    let boundIndex = -1;\n    const boundInfos = poses.map(pos => checkBoundOneWayDist(moveable, pos));\n\n    boundInfos.forEach((info, i) => {\n        if (!info) {\n            return;\n        }\n        if (!boundInfo || boundInfo.dist < info.dist) {\n            boundInfo = info;\n            boundIndex = i;\n        }\n    });\n    if (boundInfo) {\n        const nextDist = solveNextDist(\n            reversePoses[boundIndex],\n            poses[boundIndex],\n            boundInfo.offset,\n            boundInfo.isVertical,\n            isDirectionVertical,\n            datas,\n        );\n\n        if (!isNaN(nextDist)) {\n            posOffset = nextDist;\n        }\n    } else  {\n        poses.some((pos, i) => {\n            const nextDist = checkBoundOneWayPos(moveable, pos, reversePoses[i], isDirectionVertical, datas);\n\n            if (isNaN(nextDist)) {\n                return false;\n            }\n            posOffset = nextDist;\n            return true;\n        });\n    }\n    return posOffset;\n}\nexport function checkOneWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n) {\n\n    const directionIndex = direction[0] !== 0 ? 0 : 1;\n    const isDirectionVertical = directionIndex > 0;\n    const reversePoses = poses.slice().reverse();\n    let directionPoses!: number[][];\n    let reverseDirectionPoses!: number[][];\n\n    if (moveable.props.keepRatio) {\n        directionPoses = [getPosByDirection(poses, direction)];\n        reverseDirectionPoses = [getPosByDirection(reversePoses, direction)];\n    } else {\n        directionPoses = getPosesByDirection(poses, direction);\n        reverseDirectionPoses = getPosesByDirection(reversePoses, direction);\n\n        directionPoses.push([\n            (directionPoses[0][0] + directionPoses[1][0]) / 2,\n            (directionPoses[0][1] + directionPoses[1][1]) / 2,\n        ]);\n        reverseDirectionPoses.reverse();\n        reverseDirectionPoses.push([\n            (reverseDirectionPoses[0][0] + reverseDirectionPoses[1][0]) / 2,\n            (reverseDirectionPoses[0][1] + reverseDirectionPoses[1][1]) / 2,\n        ]);\n    }\n\n    const posOffset = checkOneWayPos(moveable, directionPoses, reverseDirectionPoses, isDirectionVertical, datas);\n\n    const offset = [0, 0];\n\n    offset[directionIndex] = direction[directionIndex] * posOffset;\n    return offset;\n}\nexport function checkTwoWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    is3d: boolean,\n) {\n    const directionPoses = getPosesByDirection(poses, direction);\n    const verticalDirection = [direction[0], direction[1] * -1];\n    const horizontalDirection = [direction[0] * -1, direction[1]];\n    const verticalPos = getPosByDirection(poses, verticalDirection);\n    const horizontalPos = getPosByDirection(poses, horizontalDirection);\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [directionPoses[0][0]],\n        [directionPoses[0][1]],\n    );\n\n    // share drag event\n    let widthDist = 0;\n    let heightDist = 0;\n\n    const verticalBoundInfo = checkBoundOneWayDist(moveable, verticalPos);\n    const horizontalBoundInfo = checkBoundOneWayDist(moveable, horizontalPos);\n    const isVeritcalDirectionBound = verticalBoundInfo && verticalBoundInfo.dist > Math.abs(verticalBoundOffset);\n    const isHorizontalDirectionBound\n        = horizontalBoundInfo && horizontalBoundInfo.dist > Math.abs(horizontalBoundOffset);\n\n    if (!isVeritcalDirectionBound && !isHorizontalDirectionBound) {\n        const {\n            horizontal: {\n                offset: horizontalOffset,\n            },\n            vertical: {\n                offset: verticalOffset,\n            },\n        } = checkSnapPoses(\n            moveable,\n            [directionPoses[0][0]],\n            [directionPoses[0][1]],\n        );\n        [widthDist, heightDist] = getDragDist({\n            datas,\n            distX: -(isVerticalBound ? verticalBoundOffset : verticalOffset),\n            distY: -(isHorizontalBound ? horizontalBoundOffset : horizontalOffset),\n        });\n    } else if (isVeritcalDirectionBound) {\n        // left to right, right to left\n        const reversePos = getPosByDirection(poses, [\n            verticalDirection[0] * -1,\n            verticalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            verticalBoundInfo!.offset, verticalBoundInfo!.isVertical,\n            false, datas,\n        );\n        if (!isNaN(nextDist)) {\n            widthDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        heightDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, verticalDirection)] ,\n            true,\n            datas,\n        );\n    } else {\n        // top to bottom, bottom to top\n        const reversePos = getPosByDirection(poses, [\n            horizontalDirection[0] * -1,\n            horizontalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            horizontalBoundInfo!.offset, horizontalBoundInfo!.isVertical,\n            true, datas,\n        );\n        if (!isNaN(nextDist)) {\n            heightDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        widthDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, horizontalDirection)] ,\n            false,\n            datas,\n        );\n    }\n\n    return [\n        direction[0] * widthDist,\n        direction[1] * heightDist,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManager<any, any>,\n    matrix: number[],\n    width: number,\n    height: number,\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n    is3d: boolean,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const fixedPos = getPosByReverseDirection(poses, snapDirection);\n    const nextPoses = getFixedPoses(matrix, width, height, fixedPos, direction, is3d);\n\n    if (direction[0] && direction[1]) {\n        return checkTwoWayDist(\n            moveable, nextPoses, direction, datas,\n            matrix, width, height, fixedPos, is3d,\n        );\n    } else {\n        return checkOneWayDist(moveable, nextPoses, direction, datas);\n    }\n\n}\nexport function checkSnapSize(\n    moveable: MoveableManager<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(moveable, matrix, width, height, direction, direction, datas, is3d);\n}\nexport function checkSnapScale(\n    moveable: MoveableManager<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const sizeDist = checkSizeDist(\n        moveable, scaleMatrix(datas, scale),\n        width, height,\n        direction,\n        snapDirection,\n        datas, datas.is3d,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return;\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return;\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    snapDirection: number[] | true,\n) {\n    if (snapDirection === true) {\n        const rect = getRect(poses);\n\n        (rect as any).middle = (rect.top + rect.bottom) / 2;\n        (rect as any).center = (rect.left + rect.right) / 2;\n\n        return checkSnaps(moveable, rect, true, 1);\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n        const nextPoses = [];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            poses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    } else {\n        let nextPoses!: number[][];\n\n        if (moveable.props.keepRatio) {\n            nextPoses = [getPosByDirection(poses, snapDirection)];\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    }\n}\nexport function startCheckSnapDrag(\n    moveable: MoveableManager<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\nexport function checkSnapDrag(\n    moveable: MoveableManager<any, any>,\n    distX: number,\n    distY: number,\n    datas: any,\n) {\n    const snapVerticalInfo = {\n        isSnap: false,\n        offset: 0,\n    };\n    const snapHorizontalInfo = {\n        isSnap: false,\n        offset: 0,\n    };\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [snapVerticalInfo, snapHorizontalInfo];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n\n    const snapInfos = checkSnaps(moveable, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    }, true);\n    const boundInfos = checkBounds(moveable, [left, right], [top, bottom]);\n\n    if (boundInfos.vertical.isBound) {\n        snapVerticalInfo.offset = boundInfos.vertical.offset;\n        snapVerticalInfo.isSnap = true;\n    } else if (snapInfos.vertical.isSnap) {\n        // has vertical guidelines\n        snapVerticalInfo.offset = snapInfos.vertical.offset;\n        snapVerticalInfo.isSnap = true;\n    }\n    if (boundInfos.horizontal.isBound) {\n        snapHorizontalInfo.offset = boundInfos.horizontal.offset;\n        snapHorizontalInfo.isSnap = true;\n    } else if (snapInfos.horizontal.isSnap) {\n        // has horizontal guidelines\n        snapHorizontalInfo.offset = snapInfos.horizontal.offset;\n        snapHorizontalInfo.isSnap = true;\n    }\n\n    return [\n        snapVerticalInfo,\n        snapHorizontalInfo,\n    ];\n}\n\nexport default {\n    name: \"snappable\",\n    render(moveable: MoveableManager<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapDirection,\n            clientRect,\n            containerRect,\n        } = moveable.state;\n\n        const clientLeft = clientRect.left - containerRect.left;\n        const clientTop = clientRect.top - containerRect.top;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n\n        if (!snapDirection || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n\n        const {\n            vertical: {\n                guidelines: verticalGuildelines,\n                snapPoses: verticalSnapPoses,\n            },\n            horizontal: {\n                guidelines: horizontalGuidelines,\n                snapPoses: horizontalSnapPoses,\n            },\n        } = getSnapInfosByDirection(moveable, poses, snapDirection);\n\n        const {\n            vertical: {\n                isBound: isVerticalBound,\n                pos: verticalBoundPos,\n            },\n            horizontal: {\n                isBound: isHorizontalBound,\n                pos: horizontalBoundPos,\n            },\n        } = checkBounds(moveable, [left, right], [top, bottom], 1);\n\n        if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n            // verticalGuildelines.push({\n            //     type: \"vertical\",\n            //     pos: [verticalBoundPos, top],\n            //     size: height,\n            // });\n            verticalSnapPoses.push(verticalBoundPos);\n        }\n        if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n            // horizontalGuidelines.push({\n            //     type: \"horizontal\",\n            //     pos: [left, horizontalBoundPos],\n            //     size: width,\n            // });\n            horizontalSnapPoses.push(horizontalBoundPos);\n        }\n        return [\n            ...verticalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`verticalTargetGuidline${i}`} style={{\n                    top: `${minTop}px`,\n                    left: `${-targetLeft + pos}px`,\n                    height: `${height}px`,\n                }} />;\n            }),\n            ...horizontalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`horizontalTargetGuidline${i}`} style={{\n                    top: `${-targetTop + pos}px`,\n                    left: `${minLeft}px`,\n                    width: `${width}px`,\n                }} />;\n            }),\n            ...verticalGuildelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`verticalGuidline${i}`} style={{\n                    top: `${minTop - clientTop + pos[1]}px`,\n                    left: `${-targetLeft + pos[0]}px`,\n                    height: `${size}px`,\n                }} />;\n            }),\n            ...horizontalGuidelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`horizontalGuidline${i}`} style={{\n                    top: `${-targetTop + pos[1]}px`,\n                    left: `${minLeft - clientLeft + pos[0]}px`,\n                    width: `${size}px`,\n                }} />;\n            }),\n        ];\n    },\n    dragStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapDirection = true;\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapDirection = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        moveable.state.snapDirection = true;\n        snapStart(moveable);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapDirection = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapDirection = null;\n    },\n};\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams } from \"../utils\";\nimport { minus, plus } from \"@moveable/matrix\";\nimport MoveableManager from \"../MoveableManager\";\nimport { DraggableProps, OnDrag, OnDragGroup, OnDragGroupStart, OnDragStart, OnDragEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\n\nexport default {\n    name: \"draggable\",\n    dragStart(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag } = e;\n        let { distX, distY } = e;\n        const { isPinch, isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n\n        let isSnap = false;\n\n        if (!isPinch && !parentEvent && !parentFlag) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(moveable, distX, distY, datas);\n\n            isSnap = verticalInfo.isSnap || horizontalInfo.isSnap;\n            distX -= verticalInfo.offset;\n            distY -= horizontalInfo.offset;\n        }\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n        if (!datas.isDrag) {\n            return;\n        }\n\n        moveable.state.dragger = null;\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams<OnDragEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(moveable, this, \"dragStart\", datas, e);\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDistX, passDistY } = e.datas;\n        const events = triggerChildAble(moveable, this, \"drag\", datas, { ...e, distX: passDistX, distY: passDistY });\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragEnd\", datas, e);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        }));\n\n        return isDrag;\n    },\n};\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\n\nexport function setCustomDrag(state: Partial<MoveableManagerState<any>>, delta: number[], inputEvent: any) {\n    return {\n        ...state.dragger!.move(delta, inputEvent),\n        parentEvent: true,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas = {};\n\n    public dragStart(client: number[], inputEvent: any)  {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {};\n\n        return this.move(client, inputEvent);\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { throttle, prefix, triggerEvent, fillParams } from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate, OnRotateEnd,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\n\nfunction setRotateStartInfo(\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rotationPos: number[]) {\n    datas.startAbsoluteOrigin = [\n        clientX - rotationPos[0] + origin[0],\n        clientY - rotationPos[1] + origin[1],\n    ];\n    datas.prevDeg = getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getDeg(\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    const {\n        prevDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevDeg = prevLoop * 360 + prevDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    const delta = direction * (absoluteDeg - absolutePrevDeg);\n    const dist = direction * (absoluteDeg - startRotate);\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getRotateInfo(\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n    );\n}\n\nexport function getPositions(\n    rotationPosition: \"top\" | \"bottom\" | \"left\" | \"right\",\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n) {\n    if (rotationPosition === \"left\") {\n        return [pos3, pos1];\n    } else if (rotationPosition === \"right\") {\n        return [pos2, pos4];\n    } else if (rotationPosition === \"bottom\") {\n        return [pos4, pos3];\n    }\n    return [pos1, pos2];\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getRotationPosition(\n    [pos1, pos2]: number[][],\n    rad: number,\n): number[] {\n    const relativeRotationPos = rotateMatrix([0, -40, 1], rad);\n\n    const rotationPos = [\n        (pos1[0] + pos2[0]) / 2 + relativeRotationPos[0],\n        (pos1[1] + pos2[1]) / 2 + relativeRotationPos[1],\n    ];\n\n    return rotationPos;\n}\n\nfunction dragControlCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n\n    render(moveable: MoveableManager<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { pos1, pos2, pos3, pos4, direction } = moveable.state;\n        const poses = getPositions(rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationRad = getRotationRad(poses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(${(poses[0][0] + poses[1][0]) / 2}px, ${(poses[0][1] + poses[1][1]) / 2}px) translateY(-40px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManager<RotatableProps>,\n        e: any) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n            pos1, pos2, pos3, pos4,\n        } = moveable.state;\n\n        if (!target) {\n            return false;\n        }\n\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        const poses = getPositions(moveable.props.rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationPos = getRotationPosition(\n            poses,\n            getRotationRad(poses, direction),\n        );\n\n        if (pinchFlag || parentFlag) {\n            datas.beforeInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n            datas.afterInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n        } else {\n            datas.afterInfo = {};\n            datas.beforeInfo = {};\n            setRotateStartInfo(datas.afterInfo, clientX, clientY, origin, rotationPos);\n            setRotateStartInfo(datas.beforeInfo, clientX, clientY, beforeOrigin, rotationPos);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (pinchFlag || parentFlag) {\n            [delta, dist, rotate] = getDeg(afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate] = getRotateInfo(afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!pinchFlag,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillParams<OnRotateEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n        return datas.isDrag ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent),\n                );\n\n                result.drag = dragResult;\n            },\n        );\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        moveable.rotation += params.beforeDelta;\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnRotateGroupEnd = fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { prefix, getControlTransform } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer } from \"./types\";\nimport { DIRECTION_INDEXES } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const { pos1, pos2, pos3, pos4 } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const poses = [pos1, pos2, pos3, pos4];\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(direction => {\n        directionMap[direction] = true;\n    });\n    return directions.map(direction => {\n        const indexes = DIRECTION_INDEXES[direction];\n\n        if (!indexes || !directionMap[direction]) {\n            return null;\n        }\n        return (\n            <div className={prefix(\"control\", \"direction\", direction)} data-direction={direction} key={direction}\n                style={getControlTransform(...indexes.map(index => poses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"], React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    getAbsolutePosesByState, fillParams, getKeepRatioHeight, getKeepRatioWidth,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getPosByReverseDirection,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd,\n} from \"../types\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport {\n    triggerChildAble, directionCondition,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n\n    render(moveable: MoveableManager<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            pinchFlag,\n            datas,\n        } = e;\n        const {\n            target: inputTarget,\n        } = inputEvent;\n\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !pinchFlag && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.offsetWidth = width;\n        datas.offsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        datas.width = width;\n        datas.height = height;\n        datas.transformOrigin = moveable.props.transformOrigin;\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.width = startWidth;\n                datas.height = startHeight;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapDirection = direction;\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, pinchFlag,\n            parentDistance, parentScale, inputEvent,\n            dragClient,\n        } = e;\n        const {\n            direction,\n            width,\n            height,\n            offsetWidth,\n            offsetHeight,\n            prevWidth,\n            prevHeight,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentScale;\n        const isWidth = direction[0] || !direction[1];\n        const ratio = isWidth ? offsetHeight / offsetWidth : offsetWidth / offsetHeight;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        // diagonal\n        if (parentScale) {\n            distWidth = (parentScale[0] - 1) * offsetWidth;\n            distHeight = (parentScale[1] - 1) * offsetHeight;\n\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * offsetHeight / offsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = direction[0] * dist[0];\n            distHeight = direction[1] * dist[1];\n\n            if (keepRatio && offsetWidth && offsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [offsetWidth, offsetHeight]);\n                const size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = direction[0] || keepRatio ? Math.max(offsetWidth + distWidth, 0) : offsetWidth;\n        let nextHeight = direction[1] || keepRatio ? Math.max(offsetHeight + distHeight, 0) : offsetHeight;\n\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas);\n        }\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n\n        distWidth = nextWidth - offsetWidth;\n        distHeight = nextHeight - offsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        if (!parentMoveable && delta.every(num => !num)) {\n            return;\n        }\n\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getResizeDist(moveable, nextWidth, nextHeight, direction, transformOrigin, dragClient);\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: width + distWidth,\n            height: height + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillParams<OnResizeEnd>(moveable, e, {\n            isDrag,\n        });\n        triggerEvent(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n            direction,\n        } = params;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const prevPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return { ...e, parentScale, dragClient: plus(prevPos, [clientX, clientY]) };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import {\n    throttle, getDirection, triggerEvent, multiply2, getAbsolutePosesByState,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport { setDragStart, getDragDist, getScaleDist, getPosByReverseDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart, OnScale, OnScaleEnd,\n} from \"../types\";\nimport {\n    directionCondition, triggerChildAble,\n} from \"../groupUtils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray } from \"@daybrush/utils\";\n\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    render(moveable: MoveableManager<Partial<ResizableProps & ScalableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, pinchFlag, inputEvent } = e;\n        const { target: inputTarget } = inputEvent;\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!pinchFlag) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapDirection = direction;\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY, parentScale, parentDistance,\n            parentFlag, pinchFlag, inputEvent,\n            dragClient,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentScale;\n        const state = moveable.state;\n        const isWidth = direction[0] || !direction[1];\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n\n        if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = direction[0] * dist[0];\n            let distHeight = direction[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n        scaleX = direction[0] ? scaleX * startScale[0] : startScale[0];\n        scaleY = direction[1] ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n        let snapDirection = direction;\n\n        if (moveable.props.groupable) {\n            snapDirection = [\n                (nowDist[0] >= 0 ? 1 : -1) * direction[0],\n                (nowDist[1] >= 0 ? 1 : -1) * direction[1],\n            ];\n            const stateDirection = state.snapDirection;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapDirection = snapDirection;\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapScale(moveable, nowDist, direction, snapDirection, datas);\n        }\n\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {\n            return false;\n        }\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getScaleDist(moveable, delta, direction, dragClient);\n\n        const params = fillParams<OnScale>(moveable, e, {\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillParams<OnScaleEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        const { scale, direction, dist } = params;\n        const prevPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), multiply2(direction, dist));\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * scale[0],\n                        childDatas.originalY * scale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return { ...e, parentScale: scale, dragClient: plus(prevPos, [clientX, clientY]) };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import { prefix, getLineStyle, getDirection, getAbsolutePosesByState, triggerEvent, fillParams } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    convertMatrixtoCSS, caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    multiplyCSS,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"@moveable/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { checkSnapPoses, hasGuidelines } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    render(moveable: MoveableManager<ResizableProps & ScalableProps & WarpableProps>, React: Renderer) {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return;\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(target: HTMLElement | SVGElement) {\n        return hasClass(target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManager<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map((p, i) => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapDirection = direction;\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return result;\n    },\n    dragControl(\n        moveable: MoveableManager<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n            const snapInfos = checkSnapPoses(\n                moveable,\n                selectedPoses.map(pos => pos[0] + distX),\n                selectedPoses.map(pos => pos[1] + distY),\n            );\n            const {\n                horizontal: {\n                    offset: horizontalOffset,\n                },\n                vertical: {\n                    offset: verticalOffset,\n                },\n            } = snapInfos;\n\n            distY -= horizontalOffset;\n            distX -= verticalOffset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[1],\n            poses[2],\n            poses[3],\n            nextPoses[0],\n            nextPoses[1],\n            nextPoses[2],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n        const transform = `${datas.targetTransform} matrix3d(${matrix.join(\",\")})`;\n\n        const delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiplyCSS(startMatrix, matrix, 4),\n            multiply: multiplyCSS,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillParams<OnWarpEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n};\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import MoveableManager from \"../MoveableManager\";\nimport { createWarpMatrix, convertMatrixtoCSS } from \"@moveable/matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { Renderer, GroupableProps, DragAreaProps, OnClick } from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManager) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    render(moveable: MoveableManager<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n\n        const { width, height, pos1, pos2, pos3, pos4 } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        );\n        const transform = h.length ? `matrix3d(${convertMatrixtoCSS(h).join(\",\")})` : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManager, { datas, clientX, clientY, inputEvent }: any) {\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const { left, top, width, height } = moveable.state.clientRect;\n        const posX = clientX - left;\n        const posY = clientY - top;\n        const rects = [\n            { left: 0, top: 0, width, height: posY - 10 },\n            { left: 0, top: 0, width: posX - 10, height },\n            { left: 0, top: posY + 10, width, height: height - posY - 10 },\n            { left: posX + 10, top: 0, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n    },\n    drag(moveable: MoveableManager, { datas }: any) {\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManager<DragAreaProps>, e: any) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroup,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix, getControlTransform } from \"../utils\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    render(moveable: MoveableManager, React: Renderer): any {\n        if (!moveable.props.origin) {\n            return null;\n        }\n        const { beforeOrigin } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { ScrollableProps, OnScroll } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableGroup from \"../MoveableGroup\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    dragStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = props.container || document.body,\n        } = props;\n\n        const scrollClientRect = scrollContainer.getBoundingClientRect();\n        const datas = e.datas;\n        datas.scrollContainer = scrollContainer;\n        datas.scrollRect = {\n            left: scrollClientRect.left,\n            top: scrollClientRect.top,\n            width: scrollClientRect.width,\n            height: scrollClientRect.height,\n        };\n\n        datas.isScroll = true;\n    },\n    drag(moveable: MoveableManager<ScrollableProps>, e: any) {\n        this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        e.datas.isScroll = false;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        this.drag(moveable, {...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    checkScroll(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const {\n            datas,\n            inputEvent,\n            clientX,\n            clientY,\n            isScroll,\n            targets,\n        } = e;\n\n        if (!datas.isScroll) {\n            return;\n        }\n        if (!isScroll) {\n            datas.prevClientX = clientX;\n            datas.prevClientY = clientY;\n        }\n\n        const {\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n        const {\n            scrollContainer,\n            scrollRect,\n        } = datas;\n\n        const direction = [0, 0];\n\n        if (scrollRect.top > clientY - scrollThreshold) {\n            direction[1] = -1;\n        } else if (scrollRect.top + scrollRect.height < clientY + scrollThreshold) {\n            direction[1] = 1;\n        }\n        if (scrollRect.left > clientX - scrollThreshold) {\n            direction[0] = -1;\n        } else if (scrollRect.left + scrollRect.width < clientX + scrollThreshold) {\n            direction[0] = 1;\n        }\n        if (!direction[0] && !direction[1]) {\n            return;\n        }\n\n        const pos = getScrollPosition({ scrollContainer, direction });\n        const params = fillParams<OnScroll>(moveable, e, {\n            scrollContainer,\n            direction,\n        }) as any;\n\n        const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n\n        requestAnimationFrame(() => {\n            if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {\n                return;\n            }\n\n            const nextPos = getScrollPosition({ scrollContainer, direction });\n            const offsetX = nextPos[0] - pos[0];\n            const offsetY = nextPos[1] - pos[1];\n\n            if (!offsetX && !offsetY) {\n                return;\n            }\n            moveable.targetDragger.scrollBy(direction[0] ? offsetX : 0, direction[1] ? offsetY : 0, inputEvent, false);\n\n            setTimeout(() => {\n                if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {\n                    return;\n                }\n\n                moveable.targetDragger.onDrag(inputEvent, true);\n            }, 10);\n        });\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport { Able } from \"../types\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\n\nexport const MOVEABLE_ABLES: Able[] = [\n    Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea,  Origin,\n];\n","import { refs } from \"framework-utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    render(moveable: MoveableGroup, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return [...targets.map((target, i) => {\n            return <MoveableManager\n                key={i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        }),\n        ];\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState } from \"./utils\";\nimport { plus, rotate } from \"@moveable/matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // ㅠ = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n\nclass MoveableGroup extends MoveableManager<GroupableProps, any> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public rotation: number = 0;\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getAbleDragger(this, state.target!, \"targetAbles\", \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = prevProps.container !== props.container;\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const target = state.target! || this.props.target!;\n\n        if (!isTarget || (type !== \"\" && this.props.updateGroup)) {\n            // reset rotataion\n            this.rotation = 0;\n        }\n        const rotation = this.rotation;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px;width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`;\n        state.width = width;\n        state.height = height;\n\n        const info = getTargetInfo(target, this.controlBox.getElement(), this.getContainer(), state);\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.clientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        this.updateState(\n            {\n                ...info,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, RectInfo } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & T> implements MoveableInterface {\n    public moveable!: MoveableManager<MoveableProps> | MoveableGroup;\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            };\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n    public isMoveableElement(target: HTMLElement) {\n        return this.moveable.isMoveableElement(target);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        this.moveable.dragStart(e);\n    }\n    public isInside(clientX: number, clientY: number) {\n        return this.moveable.isInside(clientX, clientY);\n    }\n    public updateRect() {\n        this.moveable.updateRect();\n    }\n    public updateTarget() {\n        this.moveable.updateTarget();\n    }\n    public getRect(): RectInfo {\n        return this.moveable.getRect();\n    }\n    public destroy() {\n        this.moveable.componentWillUnmount();\n    }\n}\n"],"names":["agent","getAgent","isWebkit","os","name","indexOf","browser","PREFIX","MOVEABLE_CSS","prefixCSS","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","Math","pow","MIN_NUM","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","multiply2","pos1","pos2","prefix","_i","classNames","prefixNames","createIdentityMatrix3","createIdentityMatrix","getTransformMatrix","transform","isObject","value","splitBracket","split","map","v","parseFloat","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","a","measureSVGSize","el","unit","isHorizontal","viewBox","ownerSVGElement","baseVal","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","i","_a","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","parentElement","isEnd","position","isStatic","offsetParent","caculateMatrixStack","container","prevMatrix","prevN","matrixes","isSVGGraphicElement","tagName","toLowerCase","originalContainer","is3d","targetMatrix","isFixed","styleTransform","convertCSStoMatrix","length","matrixesLength","convertDimension","offsetLeft","offsetTop","containerRect","documentElement","getBoundingClientRect","left","top","isSVG","isUndefined","hasNotOffset","pos","push","getSVGMatrix","_b","isOffsetEnd","scrollLeft","scrollTop","mat","beforeMatrix","offsetMatrix","endContainer","reverse","forEach","slice","multiply","isMatrix3d","convertMatrixtoCSS","clientWidth","clientHeight","viewBoxWidth","width","viewBoxHeight","height","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","scale","translate","xAlign","yAlign","floor","scaleDimension","max","min","scaleMatrix","createScaleMatrix","getSVGGraphicsOffset","getBBox","bbox","svgElement","x","y","caculatePosition","caculate","convertPositionMatrix","caculatePoses","pos3","pos4","getRect","poses","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","_c","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","offset","count","inverseBeforeMatrix","invert","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","round","caculateMoveablePosition","x1","y1","x2","y2","x3","y3","_e","x4","y4","_f","originX","originY","center","pos1Rad","getRad","pos2Rad","direction","PI","getLineStyle","distX","distY","sqrt","rad","getControlTransform","reduce","prev","getSize","isOffset","isBoxSizing","boxSizing","offsetWidth","offsetHeight","hasOffset","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","getTargetInfo","parentContainer","state","beforeDirection","targetTransform","beforeOrigin","clientRect","undefined","beforePos","getClientRect","getDirection","direciton","getAttribute","dir","getAbsolutePoses","dist","plus","getAbsolutePosesByState","throttle","num","throttleArray","nums","_","unset","self","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","every","sign","fillParams","moveable","params","datas","tslib_1","clientX","clientY","inputEvent","currentTarget","triggerEvent","pseudoElt","window","filterAbles","ables","methods","enabledAbles","ableGroups","filter","able","some","method","ableGroup","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","triggerRenderStart","isGroup","isPinch","eventAffix","targets","props","triggerRender","triggerRenderEnd","sPinch","isDrag","triggerAble","ableType","eventOperation","eventType","isStart","areaElement","eventName","conditionName","updateRect","results","condition","isUpdate","dragger","updateTarget","forceUpdate","getAbleDragger","options","pinchThreshold","Dragger","ControlBoxElement","styler","renderLine","index","React","key","className","_this","conatainer","edge","parentPosition","checkUpdate","parentLeft","parentTop","ref","display","renderAbles","controlBox","getElement","parentMoveable","updateEvent","prevProps","getContainer","targetDragger","onDragStart","type","isTarget","isSetState","updateState","controlBoxElement","hasTargetAble","targetAbles","hasControlAble","controlAbles","prevTarget","dragArea","prevDragArea","isTargetChanged","isUnset","controlDragger","unsetAbles","stateTarget","stateContainer","updateAbles","isChanged","callback","dragStart","pinchStart","dragControlStart","nextState","setState","render","MoveableManager","keepRatio","getRotatiion","touches","pinchable","controlEventName","pinchAbles","canPinch","result","parentRotate","ableEvent","pinchFlag","snapDirection","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","triggerChildAble","eachEvent","ableDatas","match","childs","moveables","child","childDatas","childEvent","isFunction","parentFlag","directionCondition","hasClass","setDragStart","inverseMatrix","absoluteOrigin","startDragBeforeDist","startDragDist","getDragDist","isBefore","caculateTransformOrigin","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","average","getPosByReverseDirection","getStartPos","startPos1","startPos2","startPos3","startPos4","getDist","startPos","getNextMatrix","getScaleDist","dragClient","groupable","nextMatrix","groupLeft","groupTop","getResizeDist","prevheight","nextOrigin","snapStart","guidelines","horizontalGuidelines","verticalGuidelines","elementGuidelines","bounds","snapCenter","containerWidth","containerHeight","containerTop","containerLeft","clientTop","clientLeft","targetLeft","targetTop","elementTop","elementBottom","elementLeft","elementRight","element","enableSnap","checkBounds","verticalPoses","horizontalPoses","snapThreshold","vertical","checkBound","horizontal","isVertical","endPos","minPos","maxPos","isBound","checkSnap","targetType","targetPoses","isSnapCenter","isSnap","snapPoses","snapGuidelines","snapDist","Infinity","snapOffset","posType","targetPos","guideline","isFinite","hasGuidelines","ableName","snappable","checkSnapPoses","customSnapThreshold","checkSnaps","isCenter","verticalNames","horizontalNames","checkBoundOneWayDist","isHorizontalBound","horizontalBoundOffset","isVerticalBound","verticalBoundOffset","solveNextDist","isDirectionVertical","sizeOffset","solveEquation","NaN","widthDist","heightDist","getFixedPoses","fixedPos","nextPos","checkBoundOneWayPos","reversePos","isHorizontalSnap","horizontalOffset","horizontalDist","isVerticalSnap","verticalOffset","verticalDist","fixedHorizontal","fixedVertical","checkOneWayPos","reversePoses","posOffset","boundInfo","boundIndex","boundInfos","info","nextDist","checkOneWayDist","directionIndex","directionPoses","reverseDirectionPoses","checkTwoWayDist","verticalDirection","horizontalDirection","verticalPos","horizontalPos","verticalBoundInfo","horizontalBoundInfo","isVeritcalDirectionBound","isHorizontalDirectionBound","checkSizeDist","checkSnapSize","checkSnapScale","sizeDist","dx","dy","b","getSnapInfosByDirection","middle","alignPoses","startCheckSnapDrag","absolutePoses","checkSnapDrag","snapVerticalInfo","snapHorizontalInfo","snapInfos","minLeft","minTop","verticalGuildelines","verticalSnapPoses","horizontalSnapPoses","_g","verticalBoundPos","_h","horizontalBoundPos","dragEnd","dragControlCondition","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","parentEvent","parentDragger","startTranslate","prevDist","prevBeforeDist","set","drag","throttleDrag","verticalInfo","horizontalInfo","passDistX","passDistY","beforeTranslate","beforeDist","delta","beforeDelta","nextTransform","events","nextParams","dragGroup","setCustomDrag","move","client","isFlag","prevX","prevY","startX","startY","deltaX","deltaY","setRotateStartInfo","rotationPos","startAbsoluteOrigin","prevDeg","startDeg","loop","getDeg","deg","startRotate","throttleRotate","prevLoop","absolutePrevDeg","absoluteDeg","getRotateInfo","getPositions","rotationPosition","getRotationRad","getRotationPosition","relativeRotationPos","rotateMatrix","rotatable","rotationRad","beforeInfo","afterInfo","rotatation","isRotate","dragControl","rotate","beforeRotate","dragGroupControlCondition","parentBeforeOrigin","eventParams","childClient","prevClient","Draggable","CustomDragger","dragGroupControl","dragResult","rotation","renderControls","defaultDirections","directions","directionMap","renderAllDirections","renderDiagonalDirections","resizable","inputTarget","startWidth","startHeight","setOrigin","isResize","parentScale","throttleResize","distWidth","distHeight","standardRad","ratioRad","signSize","cos","sin","nextWidth","nextHeight","isNoSnap","inverseDelta","originalX","originalY","prevPos","scalable","startScale","isScale","throttleScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","getMiddleLinePos","dot","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","ignoreDimension","startMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","join","multiplyCSS","AREA","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","removeClass","cssText","renderPieces","isDragArea","posX","posY","rects","children","call","nextElementSibling","addClass","isMoveableElement","containsTarget","contains","prevInputTarget","targetIndex","findIndex","parentTarget","getDefaultScrollPosition","scrollContainer","scrollClientRect","scrollRect","isScroll","checkScroll","prevClientX","prevClientY","scrollThreshold","getScrollPosition","requestAnimationFrame","offsetX","offsetY","scrollBy","setTimeout","onDrag","MOVEABLE_ABLES","Snappable","Pinchable","Rotatable","Resizable","Scalable","Warpable","Scrollable","DragArea","Origin","refs","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","isContainerChanged","added","changed","removed","updateGroup","_super","Groupable","MoveableGroup","defaultProps","isArr","nextProps","moveableTarget","componentWillUnmount"],"mappings":"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"}