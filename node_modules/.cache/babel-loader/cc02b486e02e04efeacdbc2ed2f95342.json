{"ast":null,"code":"import React, { Component } from 'react';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar initialState = {\n  wrapperComponent: null,\n  contentComponent: null,\n  previousScale: 1,\n  scale: 1,\n  positionX: 0,\n  positionY: 0,\n  options: {\n    disabled: false,\n    transformEnabled: true,\n    minPositionX: null,\n    maxPositionX: null,\n    minPositionY: null,\n    maxPositionY: null,\n    minScale: 1,\n    maxScale: 8,\n    limitToBounds: true,\n    limitToWrapper: false,\n    centerContent: true,\n    wrapperClass: \"\",\n    contentClass: \"\"\n  },\n  wheel: {\n    disabled: false,\n    step: 5,\n    wheelEnabled: true,\n    touchPadEnabled: true,\n    limitsOnWheel: false\n  },\n  pan: {\n    disabled: false,\n    panAnimationType: \"linear\",\n    lockAxisX: false,\n    lockAxisY: false,\n    velocity: true,\n    velocityEqualToMove: true,\n    velocitySensitivity: 2,\n    velocityActiveScale: 1,\n    velocityMinSpeed: 1,\n    velocityBaseTime: 1600,\n    velocityAnimationType: \"easeOutQuart\",\n    padding: true,\n    paddingSize: 30,\n    panReturnAnimationTime: 400,\n    panReturnAnimationType: \"easeOut\",\n    disableOnTarget: []\n  },\n  pinch: {\n    disabled: false\n  },\n  zoomIn: {\n    disabled: false,\n    step: 20,\n    animation: true,\n    animationType: \"easeOut\",\n    animationTime: 200\n  },\n  zoomOut: {\n    disabled: false,\n    step: 20,\n    animation: true,\n    animationType: \"easeOut\",\n    animationTime: 200\n  },\n  doubleClick: {\n    disabled: false,\n    step: 20,\n    mode: \"zoomIn\",\n    animation: true,\n    animationType: \"easeOut\",\n    animationTime: 200\n  },\n  reset: {\n    disabled: false,\n    animation: true,\n    animationType: \"easeOut\",\n    animationTime: 200\n  },\n  scalePadding: {\n    disabled: false,\n    size: 0.2,\n    animationTime: 200,\n    animationType: \"easeOut\"\n  }\n};\n/**\r\n * Rounds number to given decimal\r\n * eg. roundNumber(2.34343, 1) => 2.3\r\n */\n\nvar roundNumber = function roundNumber(num, decimal) {\n  return Number(num.toFixed(decimal));\n};\n/**\r\n * Checks if value is number, if not it returns default value\r\n * 1# eg. checkIsNumber(2, 30) => 2\r\n * 2# eg. checkIsNumber(null, 30) => 30\r\n */\n\n\nvar checkIsNumber = function checkIsNumber(num, defaultValue) {\n  return typeof num === \"number\" ? num : defaultValue;\n};\n/**\r\n * Keeps value between given bounds, used for limiting view to given boundaries\r\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\r\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\r\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\r\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\r\n */\n\n\nvar boundLimiter = function boundLimiter(value, minBound, maxBound, isActive) {\n  if (!isActive) return roundNumber(value, 2);\n  if (value < minBound) return roundNumber(minBound, 2);\n  if (value > maxBound) return roundNumber(maxBound, 2);\n  return roundNumber(value, 2);\n};\n/**\r\n * Calculate bounding area of zoomed/panned element\r\n */\n\n\nvar calculateBoundingArea = function calculateBoundingArea(wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, limitToWrapper) {\n  var scaleWidthFactor = wrapperWidth > newContentWidth ? diffWidth * (limitToWrapper ? 1 : 0.5) : 0;\n  var scaleHeightFactor = wrapperHeight > newContentHeight ? diffHeight * (limitToWrapper ? 1 : 0.5) : 0;\n  var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\n  var maxPositionX = scaleWidthFactor;\n  var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\n  var maxPositionY = scaleHeightFactor;\n  return {\n    minPositionX: minPositionX,\n    maxPositionX: maxPositionX,\n    minPositionY: minPositionY,\n    maxPositionY: maxPositionY\n  };\n};\n/**\r\n * Returns distance between two points x,y\r\n */\n\n\nvar getDistance = function getDistance(firstPoint, secondPoint) {\n  return Math.sqrt(Math.pow(firstPoint.pageX - secondPoint.pageX, 2) + Math.pow(firstPoint.pageY - secondPoint.pageY, 2));\n};\n/**\r\n * Delete undefined values from object keys\r\n * Used for deleting empty props\r\n */\n\n\nvar deleteUndefinedProps = function deleteUndefinedProps(value) {\n  var newObject = _assign({}, value);\n\n  Object.keys(newObject).forEach(function (key) {\n    return newObject[key] === undefined && delete newObject[key];\n  });\n  return newObject;\n};\n/**\r\n * Fire callback if it's function\r\n */\n\n\nvar handleCallback = function handleCallback(callback, props) {\n  if (callback && typeof callback === \"function\") {\n    callback(props);\n  }\n};\n\nvar handleWheelStop = function handleWheelStop(previousEvent, event, stateProvider) {\n  var scale = stateProvider.scale,\n      _a = stateProvider.options,\n      maxScale = _a.maxScale,\n      minScale = _a.minScale;\n  if (!previousEvent) return false;\n  if (scale < maxScale || scale > minScale) return true;\n  if (Math.sign(previousEvent.deltaY) !== Math.sign(event.deltaY)) return true;\n  if (previousEvent.deltaY > 0 && previousEvent.deltaY < event.deltaY) return true;\n  if (previousEvent.deltaY < 0 && previousEvent.deltaY > event.deltaY) return true;\n  if (Math.sign(previousEvent.deltaY) !== Math.sign(event.deltaY)) return true;\n  return false;\n};\n\nvar mergeProps = function mergeProps(initialState, dynamicProps) {\n  return Object.keys(initialState).reduce(function (acc, curr) {\n    if (typeof dynamicProps[curr] === \"object\" && dynamicProps[curr] !== null) {\n      acc[curr] = _assign(_assign({}, initialState[curr]), dynamicProps[curr]);\n    } else {\n      acc[curr] = dynamicProps[curr] === undefined ? initialState[curr] : dynamicProps[curr];\n    }\n\n    return acc;\n  }, {});\n};\n\nfunction getWindowScaleY(wrapper) {\n  if (!wrapper) return 0;\n  return window.innerHeight / wrapper.offsetHeight;\n}\n\nfunction getWindowScaleX(wrapper) {\n  if (!wrapper) return 0;\n  return window.innerWidth / wrapper.offsetWidth;\n}\n/**\r\n * Functions should return denominator of the target value, which is the next animation step.\r\n * t is a value from 0 to 1, reflecting the percentage of animation status.\r\n */\n\n\nvar easeOut = function easeOut(t) {\n  return -Math.cos(t * Math.PI) / 2 + 0.5;\n}; // linear\n\n\nvar linear = function linear(t) {\n  return t;\n}; // accelerating from zero velocity\n\n\nvar easeInQuad = function easeInQuad(t) {\n  return t * t;\n}; // decelerating to zero velocity\n\n\nvar easeOutQuad = function easeOutQuad(t) {\n  return t * (2 - t);\n}; // acceleration until halfway, then deceleration\n\n\nvar easeInOutQuad = function easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}; // accelerating from zero velocity\n\n\nvar easeInCubic = function easeInCubic(t) {\n  return t * t * t;\n}; // decelerating to zero velocity\n\n\nvar easeOutCubic = function easeOutCubic(t) {\n  return --t * t * t + 1;\n}; // acceleration until halfway, then deceleration\n\n\nvar easeInOutCubic = function easeInOutCubic(t) {\n  return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n}; // accelerating from zero velocity\n\n\nvar easeInQuart = function easeInQuart(t) {\n  return t * t * t * t;\n}; // decelerating to zero velocity\n\n\nvar easeOutQuart = function easeOutQuart(t) {\n  return 1 - --t * t * t * t;\n}; // acceleration until halfway, then deceleration\n\n\nvar easeInOutQuart = function easeInOutQuart(t) {\n  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n}; // accelerating from zero velocity\n\n\nvar easeInQuint = function easeInQuint(t) {\n  return t * t * t * t * t;\n}; // decelerating to zero velocity\n\n\nvar easeOutQuint = function easeOutQuint(t) {\n  return 1 + --t * t * t * t * t;\n}; // acceleration until halfway, then deceleration\n\n\nvar easeInOutQuint = function easeInOutQuint(t) {\n  return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\n\nvar availableAnimations = {\n  easeOut: easeOut,\n  linear: linear,\n  easeInQuad: easeInQuad,\n  easeOutQuad: easeOutQuad,\n  easeInOutQuad: easeInOutQuad,\n  easeInCubic: easeInCubic,\n  easeOutCubic: easeOutCubic,\n  easeInOutCubic: easeInOutCubic,\n  easeInQuart: easeInQuart,\n  easeOutQuart: easeOutQuart,\n  easeInOutQuart: easeInOutQuart,\n  easeInQuint: easeInQuint,\n  easeOutQuint: easeOutQuint,\n  easeInOutQuint: easeInOutQuint\n};\n\nfunction handleDisableAnimation() {\n  if (!this.mounted) return;\n\n  if (this.animation) {\n    cancelAnimationFrame(this.animation);\n  }\n\n  this.animate = false;\n  this.animation = false;\n  this.velocity = false;\n}\n\nfunction animate(animationName, animationTime, callback) {\n  var _this = this;\n\n  if (!this.mounted) return;\n  var startTime = new Date().getTime();\n  var lastStep = 1; // if another animation is active\n\n  handleDisableAnimation.call(this); // new animation\n\n  this.animation = function () {\n    if (!_this.animation || !_this.mounted) return;\n    var frameTime = new Date().getTime() - startTime;\n    var animationProgress = frameTime / animationTime;\n    var animationType = availableAnimations[animationName];\n    var step = animationType(animationProgress);\n\n    if (frameTime >= animationTime) {\n      callback(lastStep);\n      _this.animation = null;\n    } else {\n      callback(step);\n      requestAnimationFrame(_this.animation);\n    }\n  };\n\n  requestAnimationFrame(this.animation);\n}\n\nfunction animateComponent(_a) {\n  var _this = this;\n\n  var targetState = _a.targetState,\n      speed = _a.speed,\n      type = _a.type;\n  var _b = this.stateProvider,\n      scale = _b.scale,\n      positionX = _b.positionX,\n      positionY = _b.positionY;\n  var scaleDiff = targetState.scale - scale;\n  var positionXDiff = targetState.positionX - positionX;\n  var positionYDiff = targetState.positionY - positionY;\n\n  if (speed === 0) {\n    this.stateProvider.previousScale = this.stateProvider.scale;\n    this.stateProvider.scale = targetState.scale;\n    this.stateProvider.positionX = targetState.positionX;\n    this.stateProvider.positionY = targetState.positionY;\n    this.applyTransformation();\n  } else {\n    // animation start timestamp\n    animate.call(this, type, speed, function (step) {\n      _this.stateProvider.previousScale = _this.stateProvider.scale;\n      _this.stateProvider.scale = scale + scaleDiff * step;\n      _this.stateProvider.positionX = positionX + positionXDiff * step;\n      _this.stateProvider.positionY = positionY + positionYDiff * step; // apply animation changes\n\n      _this.applyTransformation();\n    });\n  }\n}\n\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\n  var scalePadding = enablePadding ? zoomPadding : 0;\n  var minScaleWithPadding = minScale - scalePadding;\n  if (!isNaN(maxScale) && zoom >= maxScale) return maxScale;\n  if (!isNaN(minScale) && zoom <= minScaleWithPadding) return minScaleWithPadding;\n  return zoom;\n}\n\nfunction checkPositionBounds(positionX, positionY, bounds, limitToBounds, paddingValue, wrapperComponent) {\n  var minPositionX = bounds.minPositionX,\n      minPositionY = bounds.minPositionY,\n      maxPositionX = bounds.maxPositionX,\n      maxPositionY = bounds.maxPositionY;\n  var paddingX = wrapperComponent ? paddingValue * wrapperComponent.offsetWidth / 100 : 0;\n  var paddingY = wrapperComponent ? paddingValue * wrapperComponent.offsetHeight / 100 : 0;\n  var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\n  var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction getDelta(event, customDelta) {\n  var deltaY = event ? event.deltaY < 0 ? 1 : -1 : 0;\n  var delta = checkIsNumber(customDelta, deltaY);\n  return delta;\n}\n\nfunction wheelMousePosition(event, contentComponent, scale) {\n  var contentRect = contentComponent.getBoundingClientRect(); // mouse position x, y over wrapper component\n\n  var mouseX = (event.clientX - contentRect.left) / scale;\n  var mouseY = (event.clientY - contentRect.top) / scale;\n  if (isNaN(mouseX) || isNaN(mouseY)) console.error(\"No mouse or touch offset found\");\n  return {\n    mouseX: mouseX,\n    mouseY: mouseY\n  };\n}\n\nfunction getComponentsSizes(wrapperComponent, contentComponent, newScale) {\n  var wrapperWidth = wrapperComponent.offsetWidth;\n  var wrapperHeight = wrapperComponent.offsetHeight;\n  var contentWidth = contentComponent.offsetWidth;\n  var contentHeight = contentComponent.offsetHeight;\n  var newContentWidth = contentWidth * newScale;\n  var newContentHeight = contentHeight * newScale;\n  var newDiffWidth = wrapperWidth - newContentWidth;\n  var newDiffHeight = wrapperHeight - newContentHeight;\n  return {\n    wrapperWidth: wrapperWidth,\n    wrapperHeight: wrapperHeight,\n    newContentWidth: newContentWidth,\n    newDiffWidth: newDiffWidth,\n    newContentHeight: newContentHeight,\n    newDiffHeight: newDiffHeight\n  };\n}\n\nfunction handleCalculatePositions(mouseX, mouseY, newScale, bounds, limitToBounds) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      positionX = _a.positionX,\n      positionY = _a.positionY,\n      transformEnabled = _a.options.transformEnabled;\n  var scaleDifference = newScale - scale;\n  if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") return console.error(\"Mouse X and Y position were not provided!\");\n  if (!transformEnabled) return {\n    newPositionX: positionX,\n    newPositionY: positionY\n  };\n  var calculatedPositionX = positionX - mouseX * scaleDifference;\n  var calculatedPositionY = positionY - mouseY * scaleDifference; // do not limit to bounds when there is padding animation,\n  // it causes animation strange behaviour\n\n  var newPositions = checkPositionBounds(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, null);\n  return newPositions;\n}\n\nfunction getClientPosition(event) {\n  var touches = event.touches; // Mobile points\n\n  if (touches && touches.length === 1) {\n    return {\n      clientX: touches[0].clientX,\n      clientY: touches[0].clientY\n    };\n  } // Desktop points\n\n\n  if (!touches) {\n    return {\n      clientX: event.clientX,\n      clientY: event.clientY\n    };\n  }\n\n  return null;\n}\n\nfunction handlePanning(event) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      positionX = _a.positionX,\n      positionY = _a.positionY,\n      _b = _a.options,\n      limitToBounds = _b.limitToBounds,\n      minScale = _b.minScale,\n      _c = _a.pan,\n      lockAxisX = _c.lockAxisX,\n      lockAxisY = _c.lockAxisY,\n      padding = _c.padding,\n      paddingSize = _c.paddingSize,\n      wrapperComponent = _a.wrapperComponent;\n  if (!this.startCoords) return;\n  var _d = this.startCoords,\n      x = _d.x,\n      y = _d.y;\n  var positions = getClientPosition(event);\n  if (!positions) return console.error(\"Cannot find mouse client positions\");\n  var clientX = positions.clientX,\n      clientY = positions.clientY; // Get Position\n\n  var mouseX = clientX - x;\n  var mouseY = clientY - y;\n  var newPositionX = lockAxisX ? positionX : mouseX;\n  var newPositionY = lockAxisY ? positionY : mouseY; // padding\n\n  var paddingValue = padding && scale >= minScale ? paddingSize : 0; // If position didn't change\n\n  if (newPositionX === positionX && newPositionY === positionY) return;\n  var calculatedPosition = checkPositionBounds(newPositionX, newPositionY, this.bounds, limitToBounds, paddingValue, wrapperComponent); // Save panned position\n\n  handlePaddingAnimation.call(this, calculatedPosition.x, calculatedPosition.y);\n}\n\nfunction handlePanningAnimation() {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      minScale = _a.options.minScale,\n      _b = _a.pan,\n      disabled = _b.disabled,\n      padding = _b.padding,\n      panReturnAnimationTime = _b.panReturnAnimationTime,\n      panReturnAnimationType = _b.panReturnAnimationType;\n  var isDisabled = disabled || scale < minScale || !padding;\n  if (isDisabled) return;\n  var targetState = handlePanToBounds.call(this);\n  animateComponent.call(this, {\n    targetState: targetState,\n    speed: panReturnAnimationTime,\n    type: panReturnAnimationType\n  });\n}\n\nfunction handlePanToBounds() {\n  var _a = this.stateProvider,\n      positionX = _a.positionX,\n      positionY = _a.positionY,\n      scale = _a.scale,\n      _b = _a.options,\n      disabled = _b.disabled,\n      limitToBounds = _b.limitToBounds,\n      limitToWrapper = _b.limitToWrapper;\n  var wrapperComponent = this.state.wrapperComponent;\n  if (disabled) return;\n  var _c = this.bounds,\n      maxPositionX = _c.maxPositionX,\n      minPositionX = _c.minPositionX,\n      maxPositionY = _c.maxPositionY,\n      minPositionY = _c.minPositionY;\n  var xChanged = positionX > maxPositionX || positionX < minPositionX;\n  var yChanged = positionY > maxPositionY || positionY < minPositionY;\n  var mouseX = positionX > maxPositionX ? wrapperComponent.offsetWidth : this.stateProvider.minPositionX || 0;\n  var mouseY = positionY > maxPositionY ? wrapperComponent.offsetHeight : this.stateProvider.minPositionY || 0;\n  var mousePosX = mouseX;\n  var mousePosY = mouseY;\n\n  var _d = handleCalculatePositions.call(this, mousePosX, mousePosY, scale, this.bounds, limitToBounds || limitToWrapper),\n      x = _d.x,\n      y = _d.y;\n\n  return {\n    scale: scale,\n    positionX: xChanged ? x : positionX,\n    positionY: yChanged ? y : positionY\n  };\n}\n\nfunction handlePaddingAnimation(positionX, positionY) {\n  var padding = this.stateProvider.pan.padding;\n  if (!padding) return;\n  this.stateProvider.positionX = positionX;\n  this.stateProvider.positionY = positionY;\n  this.applyTransformation();\n}\n\nfunction handleCalculateZoom(delta, step, disablePadding, getTarget, isBtnFunction) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      _b = _a.options,\n      maxScale = _b.maxScale,\n      minScale = _b.minScale,\n      _c = _a.scalePadding,\n      size = _c.size,\n      disabled = _c.disabled,\n      wrapperComponent = _a.wrapperComponent;\n  var targetScale = null;\n\n  if (isBtnFunction) {\n    var scaleFactor = window.innerWidth * 0.0001;\n    var zoomFactor = delta < 0 ? 30 : 20;\n    targetScale = scale + (step - step * scaleFactor) * delta * (scale / zoomFactor);\n  } else {\n    var wrapperToWindowScale = 2 - window.innerWidth / wrapperComponent.offsetWidth;\n    var scaleFactor = Math.max(0.2, Math.min(0.99, wrapperToWindowScale));\n    var zoomFactor = 20;\n    targetScale = scale + step * delta * ((scale - scale * scaleFactor) / zoomFactor);\n  }\n\n  if (getTarget) return targetScale;\n  var paddingEnabled = disablePadding ? false : !disabled;\n  var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled);\n  return newScale;\n}\n\nfunction handleCalculateBounds(newScale, limitToWrapper) {\n  var _a = this.stateProvider,\n      wrapperComponent = _a.wrapperComponent,\n      contentComponent = _a.contentComponent;\n\n  var _b = getComponentsSizes(wrapperComponent, contentComponent, newScale),\n      wrapperWidth = _b.wrapperWidth,\n      wrapperHeight = _b.wrapperHeight,\n      newContentWidth = _b.newContentWidth,\n      newDiffWidth = _b.newDiffWidth,\n      newContentHeight = _b.newContentHeight,\n      newDiffHeight = _b.newDiffHeight;\n\n  var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapper); // Save bounds\n\n  this.bounds = bounds;\n  return bounds;\n}\n/**\r\n * Wheel zoom event\r\n */\n\n\nfunction handleWheelZoom(event) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      contentComponent = _a.contentComponent,\n      limitToBounds = _a.options.limitToBounds,\n      _b = _a.scalePadding,\n      size = _b.size,\n      disabled = _b.disabled,\n      _c = _a.wheel,\n      step = _c.step,\n      limitsOnWheel = _c.limitsOnWheel;\n  event.preventDefault();\n  event.stopPropagation();\n  var delta = getDelta(event, null);\n  var newScale = handleCalculateZoom.call(this, delta, step, !event.ctrlKey); // if scale not change\n\n  if (scale === newScale) return;\n  var bounds = handleCalculateBounds.call(this, newScale, !limitsOnWheel);\n\n  var _d = wheelMousePosition(event, contentComponent, scale),\n      mouseX = _d.mouseX,\n      mouseY = _d.mouseY;\n\n  var isLimitedToBounds = limitToBounds && (disabled || size === 0 || limitsOnWheel);\n\n  var _e = handleCalculatePositions.call(this, mouseX, mouseY, newScale, bounds, isLimitedToBounds),\n      x = _e.x,\n      y = _e.y;\n\n  this.bounds = bounds;\n  this.stateProvider.previousScale = scale;\n  this.stateProvider.scale = newScale;\n  this.stateProvider.positionX = x;\n  this.stateProvider.positionY = y;\n  this.applyTransformation();\n}\n/**\r\n * Zoom for animations\r\n */\n\n\nfunction handleZoomToPoint(isDisabled, scale, mouseX, mouseY, event) {\n  var _a = this.stateProvider,\n      contentComponent = _a.contentComponent,\n      _b = _a.options,\n      disabled = _b.disabled,\n      minScale = _b.minScale,\n      maxScale = _b.maxScale,\n      limitToBounds = _b.limitToBounds,\n      limitToWrapper = _b.limitToWrapper;\n  if (disabled || isDisabled) return;\n  var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, null, null);\n  var bounds = handleCalculateBounds.call(this, newScale, limitToWrapper);\n  var mousePosX = mouseX;\n  var mousePosY = mouseY; // if event is present - use it's mouse position\n\n  if (event) {\n    var mousePosition = wheelMousePosition(event, contentComponent, scale);\n    mousePosX = mousePosition.mouseX;\n    mousePosY = mousePosition.mouseY;\n  }\n\n  var _c = handleCalculatePositions.call(this, mousePosX, mousePosY, newScale, bounds, limitToBounds),\n      x = _c.x,\n      y = _c.y;\n\n  return {\n    scale: newScale,\n    positionX: x,\n    positionY: y\n  };\n}\n\nfunction handlePaddingAnimation$1() {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      wrapperComponent = _a.wrapperComponent,\n      _b = _a.options,\n      minScale = _b.minScale,\n      limitToBounds = _b.limitToBounds,\n      _c = _a.scalePadding,\n      disabled = _c.disabled,\n      animationTime = _c.animationTime,\n      animationType = _c.animationType;\n  var isDisabled = disabled || scale >= minScale;\n\n  if (scale >= 1 || limitToBounds) {\n    // fire fit to bounds animation\n    handlePanningAnimation.call(this);\n  }\n\n  if (isDisabled) return;\n  var mouseX = wrapperComponent.offsetWidth / 2;\n  var mouseY = wrapperComponent.offsetHeight / 2;\n  var targetState = handleZoomToPoint.call(this, false, minScale, mouseX, mouseY, null);\n  animateComponent.call(this, {\n    targetState: targetState,\n    speed: animationTime,\n    type: animationType\n  });\n}\n/**\r\n * Button zoom events\r\n */\n\n\nfunction handleDoubleClick(event) {\n  event.preventDefault();\n  event.stopPropagation();\n  var _a = this.stateProvider,\n      contentComponent = _a.contentComponent,\n      scale = _a.scale,\n      _b = _a.doubleClick,\n      disabled = _b.disabled,\n      mode = _b.mode,\n      step = _b.step,\n      animationTime = _b.animationTime,\n      animationType = _b.animationType;\n\n  if (mode === \"reset\") {\n    return resetTransformations.call(this, event, animationTime);\n  }\n\n  var delta = mode === \"zoomOut\" ? -1 : 1;\n  var newScale = handleCalculateZoom.call(this, delta, step, undefined, undefined, true);\n\n  var _c = wheelMousePosition(event, contentComponent, scale),\n      mouseX = _c.mouseX,\n      mouseY = _c.mouseY;\n\n  var targetState = handleZoomToPoint.call(this, disabled, newScale, mouseX, mouseY);\n  if (targetState.scale === scale) return;\n  var targetScale = handleCalculateZoom.call(this, delta, step, true, undefined, true);\n  var time = getButtonAnimationTime(targetScale, newScale, animationTime);\n  animateComponent.call(this, {\n    targetState: targetState,\n    speed: time,\n    type: animationType\n  });\n}\n\nfunction handleZoomControls(customDelta, customStep) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      positionX = _a.positionX,\n      positionY = _a.positionY,\n      wrapperComponent = _a.wrapperComponent,\n      zoomIn = _a.zoomIn,\n      zoomOut = _a.zoomOut;\n  var wrapperWidth = wrapperComponent.offsetWidth;\n  var wrapperHeight = wrapperComponent.offsetHeight;\n  var mouseX = (wrapperWidth / 2 - positionX) / scale;\n  var mouseY = (wrapperHeight / 2 - positionY) / scale;\n  var newScale = handleCalculateZoom.call(this, customDelta, customStep, undefined, undefined, true);\n  var isZoomIn = newScale > scale;\n  var animationSpeed = isZoomIn ? zoomIn.animationTime : zoomOut.animationTime;\n  var animationType = isZoomIn ? zoomIn.animationType : zoomOut.animationType;\n  var isDisabled = isZoomIn ? zoomIn.disabled : zoomOut.disabled;\n  var targetState = handleZoomToPoint.call(this, isDisabled, newScale, mouseX, mouseY);\n  if (targetState.scale === scale) return;\n  var targetScale = handleCalculateZoom.call(this, customDelta, customStep, true, undefined, true);\n  var time = getButtonAnimationTime(targetScale, newScale, animationSpeed);\n  animateComponent.call(this, {\n    targetState: targetState,\n    speed: time,\n    type: animationType\n  });\n}\n\nfunction resetTransformations(animationSpeed) {\n  var _a = this.props.defaultValues,\n      defaultScale = _a.defaultScale,\n      defaultPositionX = _a.defaultPositionX,\n      defaultPositionY = _a.defaultPositionY;\n  var _b = this.stateProvider,\n      scale = _b.scale,\n      positionX = _b.positionX,\n      positionY = _b.positionY,\n      reset = _b.reset,\n      _c = _b.options,\n      disabled = _c.disabled,\n      limitToBounds = _c.limitToBounds,\n      centerContent = _c.centerContent,\n      limitToWrapper = _c.limitToWrapper;\n  if (disabled || reset.disabled) return;\n  if (scale === defaultScale && positionX === defaultPositionX && positionY === defaultPositionY) return;\n  var speed = typeof animationSpeed === \"number\" ? animationSpeed : reset.animationTime;\n  var targetScale = checkIsNumber(defaultScale, initialState.scale);\n  var newPositionX = checkIsNumber(defaultPositionX, initialState.positionX);\n  var newPositionY = checkIsNumber(defaultPositionY, initialState.positionY);\n\n  if (limitToBounds && !limitToWrapper || centerContent) {\n    var bounds = handleCalculateBounds.call(this, targetScale, limitToWrapper);\n    newPositionX = bounds.minPositionX;\n    newPositionY = bounds.minPositionY;\n  }\n\n  var targetState = {\n    scale: targetScale,\n    positionX: newPositionX,\n    positionY: newPositionY\n  };\n  animateComponent.call(this, {\n    targetState: targetState,\n    speed: speed,\n    type: reset.animationType\n  });\n}\n\nfunction getButtonAnimationTime(targetScale, newScale, time) {\n  return time * (newScale / targetScale);\n}\n\nfunction round(number, decimal) {\n  var roundNumber = Math.pow(10, decimal);\n  return Math.round(number * roundNumber) / roundNumber;\n}\n\nfunction getCurrentDistance(event) {\n  return getDistance(event.touches[0], event.touches[1]);\n}\n\nfunction checkIfInfinite(number) {\n  return number === Infinity || number === -Infinity;\n}\n\nfunction calculatePinchZoom(currentDistance, pinchStartDistance) {\n  var _a = this.stateProvider,\n      _b = _a.options,\n      minScale = _b.minScale,\n      maxScale = _b.maxScale,\n      _c = _a.scalePadding,\n      size = _c.size,\n      disabled = _c.disabled;\n  if (typeof pinchStartDistance !== \"number\" || typeof currentDistance !== \"number\") return console.error(\"Pinch touches distance was not provided\");\n  if (currentDistance < 0) return;\n  var touchProportion = currentDistance / pinchStartDistance;\n  var scaleDifference = touchProportion * this.pinchStartScale;\n  return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled);\n}\n\nfunction calculateMidpoint(event, scale, contentComponent) {\n  var contentRect = contentComponent.getBoundingClientRect();\n  var touches = event.touches;\n  var firstPointX = round(touches[0].clientX - contentRect.left, 5);\n  var firstPointY = round(touches[0].clientY - contentRect.top, 5);\n  var secondPointX = round(touches[1].clientX - contentRect.left, 5);\n  var secondPointY = round(touches[1].clientY - contentRect.top, 5);\n  return {\n    mouseX: (firstPointX + secondPointX) / 2 / scale,\n    mouseY: (firstPointY + secondPointY) / 2 / scale\n  };\n}\n\nfunction handleZoomPinch(event) {\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      _b = _a.options,\n      limitToBounds = _b.limitToBounds,\n      limitToWrapper = _b.limitToWrapper,\n      _c = _a.scalePadding,\n      disabled = _c.disabled,\n      size = _c.size,\n      limitsOnWheel = _a.wheel.limitsOnWheel,\n      pinch = _a.pinch;\n  var contentComponent = this.state.contentComponent;\n  if (pinch.disabled || this.stateProvider.options.disabled) return;\n\n  if (event.cancelable) {\n    event.preventDefault();\n    event.stopPropagation();\n  } // if one finger starts from outside of wrapper\n\n\n  if (this.pinchStartDistance === null) return; // Position transformation\n\n  var _d = calculateMidpoint(event, scale, contentComponent),\n      mouseX = _d.mouseX,\n      mouseY = _d.mouseY; // if touches goes off of the wrapper element\n\n\n  if (checkIfInfinite(mouseX) || checkIfInfinite(mouseY)) return;\n  var currentDistance = getCurrentDistance(event);\n  var newScale = calculatePinchZoom.call(this, currentDistance, this.pinchStartDistance);\n  if (checkIfInfinite(newScale) || newScale === scale) return; // Get new element sizes to calculate bounds\n\n  var bounds = handleCalculateBounds.call(this, newScale, limitToWrapper); // Calculate transformations\n\n  var isLimitedToBounds = limitToBounds && (disabled || size === 0 || limitsOnWheel);\n\n  var _e = handleCalculatePositions.call(this, mouseX, mouseY, newScale, bounds, isLimitedToBounds),\n      x = _e.x,\n      y = _e.y;\n\n  this.lastDistance = currentDistance;\n  this.stateProvider.positionX = x;\n  this.stateProvider.positionY = y;\n  this.stateProvider.scale = newScale;\n  this.stateProvider.previousScale = scale; // update component transformation\n\n  this.applyTransformation();\n}\n\nvar throttleTime = 30;\n\nfunction velocityTimeSpeed(speed, animationTime) {\n  var velocityEqualToMove = this.stateProvider.pan.velocityEqualToMove;\n\n  if (velocityEqualToMove) {\n    return animationTime - animationTime / Math.max(1, speed);\n  }\n\n  return animationTime;\n}\n\nfunction handleEnableVelocity() {\n  this.setState({\n    startAnimation: false\n  });\n}\n\nfunction handleFireVelocity() {\n  this.setState({\n    startAnimation: true\n  });\n}\n\nfunction animateVelocity() {\n  var _this = this;\n\n  var _a = this.stateProvider,\n      positionX = _a.positionX,\n      positionY = _a.positionY,\n      limitToBounds = _a.options.limitToBounds,\n      _b = _a.pan,\n      velocityBaseTime = _b.velocityBaseTime,\n      lockAxisX = _b.lockAxisX,\n      lockAxisY = _b.lockAxisY,\n      velocityAnimationType = _b.velocityAnimationType,\n      panReturnAnimationTime = _b.panReturnAnimationTime,\n      panReturnAnimationType = _b.panReturnAnimationType,\n      padding = _b.padding,\n      paddingSize = _b.paddingSize,\n      wrapperComponent = _a.wrapperComponent;\n  if (!this.mounted) return;\n  if (!this.velocity || !this.bounds) return handleDisableAnimation.call(this);\n  var _c = this.bounds,\n      maxPositionX = _c.maxPositionX,\n      minPositionX = _c.minPositionX,\n      maxPositionY = _c.maxPositionY,\n      minPositionY = _c.minPositionY;\n  var _d = this.velocity,\n      velocityX = _d.velocityX,\n      velocityY = _d.velocityY,\n      velocity = _d.velocity;\n  var animationTime = velocityTimeSpeed.call(this, velocity, velocityBaseTime);\n\n  if (!animationTime) {\n    handlePanningAnimation.call(this);\n    return;\n  }\n\n  var targetX = velocityX;\n  var targetY = velocityY; // pan return animation\n\n  var newAnimationTime = animationTime > panReturnAnimationTime ? animationTime : panReturnAnimationTime;\n  var paddingValue = padding ? paddingSize : 0;\n  var paddingX = wrapperComponent ? paddingValue * wrapperComponent.offsetWidth / 100 : 0;\n  var paddingY = wrapperComponent ? paddingValue * wrapperComponent.offsetHeight / 100 : 0;\n  var maxTargetX = maxPositionX + paddingX;\n  var minTargetX = minPositionX - paddingX;\n  var maxTargetY = maxPositionY + paddingY;\n  var minTargetY = minPositionY - paddingY;\n  var startPosition = checkPositionBounds(positionX, positionY, this.bounds, limitToBounds, paddingValue, wrapperComponent);\n  var startTime = new Date().getTime(); // animation start timestamp\n\n  animate.call(this, velocityAnimationType, newAnimationTime, function (step) {\n    var frameTime = new Date().getTime() - startTime;\n    var animationProgress = frameTime / panReturnAnimationTime;\n    var returnAnimation = availableAnimations[panReturnAnimationType];\n    var customReturnStep = returnAnimation(animationProgress);\n    if (frameTime > panReturnAnimationTime || customReturnStep > 1 || customReturnStep === Infinity || customReturnStep === -Infinity) customReturnStep = 1;\n    var currentPositionX = getPosition(lockAxisX, targetX, step, customReturnStep, minPositionX, maxPositionX, limitToBounds, positionX, startPosition.x, minTargetX, maxTargetX);\n    var currentPositionY = getPosition(lockAxisY, targetY, step, customReturnStep, minPositionY, maxPositionY, limitToBounds, positionY, startPosition.y, minTargetY, maxTargetY);\n\n    if (positionX !== currentPositionX || positionY !== currentPositionY) {\n      // Save panned position\n      _this.stateProvider.positionX = currentPositionX;\n      _this.stateProvider.positionY = currentPositionY; // apply animation changes\n\n      _this.applyTransformation();\n    }\n  });\n}\n\nfunction calculateVelocityStart(event) {\n  var _this = this;\n\n  var _a = this.stateProvider,\n      scale = _a.scale,\n      disabled = _a.options.disabled,\n      _b = _a.pan,\n      velocity = _b.velocity,\n      velocitySensitivity = _b.velocitySensitivity,\n      velocityActiveScale = _b.velocityActiveScale,\n      velocityMinSpeed = _b.velocityMinSpeed,\n      wrapperComponent = _a.wrapperComponent;\n  if (!velocity || velocityActiveScale >= scale || disabled) return;\n  handleEnableVelocity.call(this);\n  var now = Date.now();\n\n  if (this.lastMousePosition) {\n    var position_1 = getClientPosition(event);\n    if (!position_1) return console.error(\"No mouse or touch position detected\");\n    var clientX = position_1.clientX,\n        clientY = position_1.clientY;\n    var distanceX = clientX - this.lastMousePosition.clientX;\n    var distanceY = clientY - this.lastMousePosition.clientY;\n    var interval = now - this.velocityTime;\n    var wrapperToWindowScaleX = 2 - wrapperComponent.offsetWidth / window.innerWidth;\n    var wrapperToWindowScaleY = 2 - wrapperComponent.offsetHeight / window.innerHeight;\n    var scaledX = 20 * Math.max(velocityMinSpeed, Math.min(2, wrapperToWindowScaleX));\n    var scaledY = 20 * Math.max(velocityMinSpeed, Math.min(2, wrapperToWindowScaleY));\n    var velocityX = distanceX / interval * velocitySensitivity * scale * scaledX;\n    var velocityY = distanceY / interval * velocitySensitivity * scale * scaledY;\n    var speed = distanceX * distanceX + distanceY * distanceY;\n    var velocity_1 = Math.sqrt(speed) / interval * velocitySensitivity;\n    if (this.velocity && velocity_1 < this.velocity.velocity && this.throttle) return;\n    this.velocity = {\n      velocityX: velocityX,\n      velocityY: velocityY,\n      velocity: velocity_1\n    }; // throttling\n\n    if (this.throttle) clearTimeout(this.throttle);\n    this.throttle = setTimeout(function () {\n      if (_this.mounted) _this.throttle = false;\n    }, throttleTime);\n  }\n\n  var position = getClientPosition(event);\n  this.lastMousePosition = position;\n  this.velocityTime = now;\n}\n\nfunction getPosition(isLocked, target, step, panReturnStep, minBound, maxBound, limitToBounds, offset, startPosition, minTarget, maxTarget) {\n  if (limitToBounds) {\n    if (startPosition > minBound && offset > maxBound) {\n      var newPosition = startPosition - (startPosition - maxBound) * panReturnStep;\n      if (newPosition > maxTarget) return maxTarget;\n      if (newPosition < maxBound) return maxBound;\n      return newPosition;\n    }\n\n    if (startPosition < minBound && offset < minBound) {\n      var newPosition = startPosition - (startPosition - minBound) * panReturnStep;\n      if (newPosition < minTarget) return minTarget;\n      if (newPosition > minBound) return minBound;\n      return newPosition;\n    }\n  }\n\n  if (isLocked) return startPosition;\n  var offsetPosition = offset + target * step;\n  return boundLimiter(offsetPosition, minBound, maxBound, limitToBounds);\n} // We want to make event listeners non-passive, and to do so have to check\n\n\nfunction makePassiveEventOption(passive) {\n  return passive;\n}\n\nvar propsList = [\"previousScale\", \"scale\", \"positionX\", \"positionY\", \"defaultPositionX\", \"defaultPositionY\", \"defaultScale\", \"onWheelStart\", \"onWheel\", \"onWheelStop\", \"onPanningStart\", \"onPanning\", \"onPanningStop\", \"onPinchingStart\", \"onPinching\", \"onPinchingStop\", \"onZoomChange\", \"options\", \"wheel\", \"scalePadding\", \"pan\", \"pinch\", \"zoomIn\", \"zoomOut\", \"doubleClick\", \"reset\"];\n\nvar getValidPropsFromObject = function getValidPropsFromObject(props) {\n  return Object.keys(props).reduce(function (acc, key) {\n    if (propsList.includes(key)) {\n      acc[key] = props[key];\n    }\n\n    return acc;\n  }, {});\n};\n\nvar Context = React.createContext({});\nvar wheelStopEventTimer = null;\nvar wheelStopEventTime = 180;\nvar wheelAnimationTimer = null;\nvar wheelAnimationTime = 100;\n\nvar StateProvider =\n/** @class */\nfunction (_super) {\n  __extends(StateProvider, _super);\n\n  function StateProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.mounted = true;\n    _this.state = {\n      wrapperComponent: undefined,\n      contentComponent: undefined\n    };\n    _this.stateProvider = _assign(_assign(_assign(_assign({}, initialState), mergeProps(initialState, _this.props.dynamicValues)), _this.props.defaultValues), {\n      previousScale: _this.props.dynamicValues.scale || _this.props.defaultValues.scale || initialState.scale\n    });\n    _this.windowToWrapperScaleX = 0;\n    _this.windowToWrapperScaleY = 0; // panning helpers\n\n    _this.startCoords = null;\n    _this.isDown = false; // pinch helpers\n\n    _this.pinchStartDistance = null;\n    _this.lastDistance = null;\n    _this.pinchStartScale = null;\n    _this.distance = null;\n    _this.bounds = null; // velocity helpers\n\n    _this.velocityTime = null;\n    _this.lastMousePosition = null;\n    _this.velocity = null;\n    _this.offsetX = null;\n    _this.offsetY = null;\n    _this.throttle = false; // wheel helpers\n\n    _this.previousWheelEvent = null;\n    _this.lastScale = null; // animations helpers\n\n    _this.animate = null;\n    _this.animation = null;\n    _this.maxBounds = null; //////////\n    // Wheel\n    //////////\n\n    _this.handleWheel = function (event) {\n      var _a = _this.stateProvider,\n          scale = _a.scale,\n          _b = _a.wheel,\n          disabled = _b.disabled,\n          wheelEnabled = _b.wheelEnabled,\n          touchPadEnabled = _b.touchPadEnabled;\n      var _c = _this.props,\n          onWheelStart = _c.onWheelStart,\n          onWheel = _c.onWheel,\n          onWheelStop = _c.onWheelStop;\n      var _d = _this.state,\n          wrapperComponent = _d.wrapperComponent,\n          contentComponent = _d.contentComponent;\n      if (_this.isDown || disabled || _this.stateProvider.options.disabled || !wrapperComponent || !contentComponent) return; // ctrlKey detects if touchpad execute wheel or pinch gesture\n\n      if (!wheelEnabled && !event.ctrlKey) return;\n      if (!touchPadEnabled && event.ctrlKey) return; // Wheel start event\n\n      if (!wheelStopEventTimer) {\n        _this.lastScale = scale;\n        handleDisableAnimation.call(_this);\n        handleCallback(onWheelStart, _this.getCallbackProps());\n      } // Wheel event\n\n\n      handleWheelZoom.call(_this, event);\n      handleCallback(onWheel, _this.getCallbackProps());\n\n      _this.applyTransformation(null, null, null);\n\n      _this.previousWheelEvent = event; // Wheel stop event\n\n      if (handleWheelStop(_this.previousWheelEvent, event, _this.stateProvider)) {\n        clearTimeout(wheelStopEventTimer);\n        wheelStopEventTimer = setTimeout(function () {\n          if (!_this.mounted) return;\n          handleCallback(onWheelStop, _this.getCallbackProps());\n          wheelStopEventTimer = null;\n        }, wheelStopEventTime);\n      } // cancel animation\n\n\n      _this.animate = false; // fire animation\n\n      _this.lastScale = _this.stateProvider.scale;\n      clearTimeout(wheelAnimationTimer);\n      wheelAnimationTimer = setTimeout(function () {\n        if (!_this.mounted) return;\n        handlePaddingAnimation$1.call(_this, event);\n      }, wheelAnimationTime);\n    }; //////////\n    // Panning\n    //////////\n\n\n    _this.checkPanningTarget = function (event) {\n      var disableOnTarget = _this.stateProvider.pan.disableOnTarget;\n      return disableOnTarget.map(function (tag) {\n        return tag.toUpperCase();\n      }).includes(event.target.tagName) || disableOnTarget.find(function (element) {\n        return event.target.classList.value.includes(element);\n      });\n    };\n\n    _this.checkIsPanningActive = function (event) {\n      var disabled = _this.stateProvider.pan.disabled;\n      var _a = _this.state,\n          wrapperComponent = _a.wrapperComponent,\n          contentComponent = _a.contentComponent;\n      return !_this.isDown || disabled || _this.stateProvider.options.disabled || event.touches && (event.touches.length !== 1 || Math.abs(_this.startCoords.x - event.touches[0].clientX) < 1 || Math.abs(_this.startCoords.y - event.touches[0].clientY) < 1) || !wrapperComponent || !contentComponent;\n    };\n\n    _this.handleSetUpPanning = function (x, y) {\n      var _a = _this.stateProvider,\n          positionX = _a.positionX,\n          positionY = _a.positionY;\n      _this.isDown = true;\n      _this.startCoords = {\n        x: x - positionX,\n        y: y - positionY\n      };\n      handleCallback(_this.props.onPanningStart, _this.getCallbackProps());\n    };\n\n    _this.handleStartPanning = function (event) {\n      var _a = _this.stateProvider,\n          wrapperComponent = _a.wrapperComponent,\n          scale = _a.scale,\n          _b = _a.options,\n          minScale = _b.minScale,\n          maxScale = _b.maxScale,\n          limitToWrapper = _b.limitToWrapper,\n          disabled = _a.pan.disabled;\n      var target = event.target,\n          touches = event.touches;\n      if (disabled || _this.stateProvider.options.disabled || wrapperComponent && !wrapperComponent.contains(target) || _this.checkPanningTarget(event) || scale < minScale || scale > maxScale) return;\n      handleDisableAnimation.call(_this);\n      _this.bounds = handleCalculateBounds.call(_this, scale, limitToWrapper); // Mobile points\n\n      if (touches && touches.length === 1) {\n        _this.handleSetUpPanning(touches[0].clientX, touches[0].clientY);\n      } // Desktop points\n\n\n      if (!touches) {\n        _this.handleSetUpPanning(event.clientX, event.clientY);\n      }\n    };\n\n    _this.handlePanning = function (event) {\n      if (_this.isDown) event.preventDefault();\n      if (_this.checkIsPanningActive(event)) return;\n      event.stopPropagation();\n      calculateVelocityStart.call(_this, event);\n      handlePanning.call(_this, event);\n      handleCallback(_this.props.onPanning, _this.getCallbackProps());\n    };\n\n    _this.handleStopPanning = function () {\n      if (_this.isDown) {\n        _this.isDown = false;\n        _this.animate = false;\n        _this.animation = false;\n        handleFireVelocity.call(_this);\n        handleCallback(_this.props.onPanningStop, _this.getCallbackProps());\n        var _a = _this.stateProvider,\n            velocity = _a.pan.velocity,\n            scale = _a.scale; // start velocity animation\n\n        if (_this.velocity && velocity && scale > 1) {\n          animateVelocity.call(_this);\n        } else {\n          // fire fit to bounds animation\n          handlePanningAnimation.call(_this);\n        }\n      }\n    }; //////////\n    // Pinch\n    //////////\n\n\n    _this.handlePinchStart = function (event) {\n      var scale = _this.stateProvider.scale;\n      event.preventDefault();\n      event.stopPropagation();\n      handleDisableAnimation.call(_this);\n      var distance = getDistance(event.touches[0], event.touches[1]);\n      _this.pinchStartDistance = distance;\n      _this.lastDistance = distance;\n      _this.pinchStartScale = scale;\n      _this.isDown = false;\n      handleCallback(_this.props.onPinchingStart, _this.getCallbackProps());\n    };\n\n    _this.handlePinch = function (event) {\n      _this.isDown = false;\n      handleZoomPinch.call(_this, event);\n      handleCallback(_this.props.onPinching, _this.getCallbackProps());\n    };\n\n    _this.handlePinchStop = function () {\n      if (typeof _this.pinchStartScale === \"number\") {\n        _this.isDown = false;\n        _this.velocity = null;\n        _this.lastDistance = null;\n        _this.pinchStartScale = null;\n        _this.pinchStartDistance = null;\n        handlePaddingAnimation$1.call(_this);\n        handleCallback(_this.props.onPinchingStop, _this.getCallbackProps());\n      }\n    }; //////////\n    // Touch Events\n    //////////\n\n\n    _this.handleTouchStart = function (event) {\n      var _a = _this.stateProvider,\n          wrapperComponent = _a.wrapperComponent,\n          contentComponent = _a.contentComponent,\n          scale = _a.scale,\n          _b = _a.options,\n          disabled = _b.disabled,\n          minScale = _b.minScale;\n      var touches = event.touches;\n      if (disabled || !wrapperComponent || !contentComponent || scale < minScale) return;\n      handleDisableAnimation.call(_this);\n      if (touches && touches.length === 1) return _this.handleStartPanning(event);\n      if (touches && touches.length === 2) return _this.handlePinchStart(event);\n    };\n\n    _this.handleTouch = function (event) {\n      var _a = _this.stateProvider,\n          pan = _a.pan,\n          pinch = _a.pinch,\n          options = _a.options;\n      if (options.disabled) return;\n      if (!pan.disabled && event.touches.length === 1) return _this.handlePanning(event);\n      if (!pinch.disabled && event.touches.length === 2) return _this.handlePinch(event);\n    };\n\n    _this.handleTouchStop = function () {\n      _this.handleStopPanning();\n\n      _this.handlePinchStop();\n    }; //////////\n    // Controls\n    //////////\n\n\n    _this.zoomIn = function (event) {\n      var _a = _this.stateProvider,\n          _b = _a.zoomIn,\n          disabled = _b.disabled,\n          step = _b.step,\n          options = _a.options;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (!event) throw Error(\"Zoom in function requires event prop\");\n      if (disabled || options.disabled || !wrapperComponent || !contentComponent) return;\n      handleZoomControls.call(_this, 1, step);\n    };\n\n    _this.zoomOut = function (event) {\n      var _a = _this.stateProvider,\n          _b = _a.zoomOut,\n          disabled = _b.disabled,\n          step = _b.step,\n          options = _a.options;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (!event) throw Error(\"Zoom out function requires event prop\");\n      if (disabled || options.disabled || !wrapperComponent || !contentComponent) return;\n      handleZoomControls.call(_this, -1, step);\n    };\n\n    _this.handleDbClick = function (event) {\n      var _a = _this.stateProvider,\n          options = _a.options,\n          _b = _a.doubleClick,\n          disabled = _b.disabled,\n          step = _b.step;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (!event) throw Error(\"Double click function requires event prop\");\n      if (disabled || options.disabled || !wrapperComponent || !contentComponent) return;\n      handleDoubleClick.call(_this, event, 1, step);\n    };\n\n    _this.setScale = function (newScale, speed, type) {\n      if (speed === void 0) {\n        speed = 200;\n      }\n\n      if (type === void 0) {\n        type = \"easeOut\";\n      }\n\n      var _a = _this.stateProvider,\n          positionX = _a.positionX,\n          positionY = _a.positionY,\n          scale = _a.scale,\n          disabled = _a.options.disabled;\n      var _b = _this.state,\n          wrapperComponent = _b.wrapperComponent,\n          contentComponent = _b.contentComponent;\n      if (disabled || !wrapperComponent || !contentComponent) return;\n      var targetState = {\n        positionX: positionX,\n        positionY: positionY,\n        scale: isNaN(newScale) ? scale : newScale\n      };\n      animateComponent.call(_this, {\n        targetState: targetState,\n        speed: speed,\n        type: type\n      });\n    };\n\n    _this.setPositionX = function (newPosX, speed, type) {\n      if (speed === void 0) {\n        speed = 200;\n      }\n\n      if (type === void 0) {\n        type = \"easeOut\";\n      }\n\n      var _a = _this.stateProvider,\n          positionX = _a.positionX,\n          positionY = _a.positionY,\n          scale = _a.scale,\n          _b = _a.options,\n          disabled = _b.disabled,\n          transformEnabled = _b.transformEnabled;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (disabled || !transformEnabled || !wrapperComponent || !contentComponent) return;\n      var targetState = {\n        positionX: isNaN(newPosX) ? positionX : newPosX,\n        positionY: positionY,\n        scale: scale\n      };\n      animateComponent.call(_this, {\n        targetState: targetState,\n        speed: speed,\n        type: type\n      });\n    };\n\n    _this.setPositionY = function (newPosY, speed, type) {\n      if (speed === void 0) {\n        speed = 200;\n      }\n\n      if (type === void 0) {\n        type = \"easeOut\";\n      }\n\n      var _a = _this.stateProvider,\n          positionX = _a.positionX,\n          scale = _a.scale,\n          positionY = _a.positionY,\n          _b = _a.options,\n          disabled = _b.disabled,\n          transformEnabled = _b.transformEnabled;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (disabled || !transformEnabled || !wrapperComponent || !contentComponent) return;\n      var targetState = {\n        positionX: positionX,\n        positionY: isNaN(newPosY) ? positionY : newPosY,\n        scale: scale\n      };\n      animateComponent.call(_this, {\n        targetState: targetState,\n        speed: speed,\n        type: type\n      });\n    };\n\n    _this.setTransform = function (newPosX, newPosY, newScale, speed, type) {\n      if (speed === void 0) {\n        speed = 200;\n      }\n\n      if (type === void 0) {\n        type = \"easeOut\";\n      }\n\n      var _a = _this.stateProvider,\n          positionX = _a.positionX,\n          positionY = _a.positionY,\n          scale = _a.scale,\n          _b = _a.options,\n          disabled = _b.disabled,\n          transformEnabled = _b.transformEnabled;\n      var _c = _this.state,\n          wrapperComponent = _c.wrapperComponent,\n          contentComponent = _c.contentComponent;\n      if (disabled || !transformEnabled || !wrapperComponent || !contentComponent) return;\n      var targetState = {\n        positionX: isNaN(newPosX) ? positionX : newPosX,\n        positionY: isNaN(newPosY) ? positionY : newPosY,\n        scale: isNaN(newScale) ? scale : newScale\n      };\n      animateComponent.call(_this, {\n        targetState: targetState,\n        speed: speed,\n        type: type\n      });\n    };\n\n    _this.resetTransform = function () {\n      var _a = _this.stateProvider.options,\n          disabled = _a.disabled,\n          transformEnabled = _a.transformEnabled;\n      if (disabled || !transformEnabled) return;\n      resetTransformations.call(_this);\n    };\n\n    _this.setDefaultState = function () {\n      _this.animation = null;\n      _this.stateProvider = _assign(_assign(_assign({}, _this.stateProvider), {\n        scale: initialState.scale,\n        positionX: initialState.positionX,\n        positionY: initialState.positionY\n      }), _this.props.defaultValues);\n\n      _this.forceUpdate();\n    }; //////////\n    // Setters\n    //////////\n\n\n    _this.setWrapperComponent = function (wrapperComponent) {\n      _this.setState({\n        wrapperComponent: wrapperComponent\n      });\n    };\n\n    _this.setContentComponent = function (contentComponent) {\n      _this.setState({\n        contentComponent: contentComponent\n      }, function () {\n        var _a = _this.stateProvider,\n            wrapperComponent = _a.wrapperComponent,\n            _b = _a.options,\n            centerContent = _b.centerContent,\n            limitToBounds = _b.limitToBounds,\n            limitToWrapper = _b.limitToWrapper,\n            scale = _a.scale;\n        var _c = _this.props.defaultValues,\n            positionX = _c.positionX,\n            positionY = _c.positionY;\n\n        if (limitToBounds && !limitToWrapper || centerContent && !positionX && !positionY) {\n          var transform = \"translate(25%, 25%) scale(\" + scale + \")\";\n          contentComponent.style.transform = transform;\n          contentComponent.style.WebkitTransform = transform; // force update to inject state to the context\n\n          _this.forceUpdate();\n\n          var startTime_1 = new Date().getTime();\n          var maxTimeWait_1 = 2000;\n          var interval_1 = setInterval(function () {\n            if (wrapperComponent.offsetWidth) {\n              var bounds = handleCalculateBounds.call(_this, scale, false);\n              _this.stateProvider.positionX = bounds.minPositionX;\n              _this.stateProvider.positionY = bounds.minPositionY;\n\n              _this.applyTransformation(null, null, null);\n\n              clearInterval(interval_1);\n              interval_1 = null;\n            } else if (new Date().getTime() - startTime_1 > maxTimeWait_1) {\n              clearInterval(interval_1);\n              interval_1 = null;\n            }\n          }, 20);\n        } else {\n          _this.applyTransformation(null, null, null);\n        }\n      });\n    };\n\n    _this.applyTransformation = function (newScale, posX, posY) {\n      if (!_this.mounted) return;\n      var contentComponent = _this.state.contentComponent;\n      var onZoomChange = _this.props.onZoomChange;\n      var _a = _this.stateProvider,\n          previousScale = _a.previousScale,\n          scale = _a.scale,\n          positionX = _a.positionX,\n          positionY = _a.positionY;\n      if (!contentComponent) return console.error(\"There is no content component\");\n      var transform = \"translate(\" + (posX || positionX) + \"px, \" + (posY || positionY) + \"px) scale(\" + (newScale || scale) + \")\";\n      contentComponent.style.transform = transform;\n      contentComponent.style.WebkitTransform = transform; // force update to inject state to the context\n\n      _this.forceUpdate();\n\n      if (onZoomChange && previousScale !== scale) {\n        handleCallback(onZoomChange, _this.getCallbackProps());\n      }\n    }; //////////\n    // Props\n    //////////\n\n\n    _this.getCallbackProps = function () {\n      return getValidPropsFromObject(_this.stateProvider);\n    };\n\n    return _this;\n  }\n\n  StateProvider.prototype.componentDidMount = function () {\n    var passiveOption = makePassiveEventOption(false); // Panning on window to allow panning when mouse is out of wrapper\n\n    window.addEventListener(\"mousedown\", this.handleStartPanning, passiveOption);\n    window.addEventListener(\"mousemove\", this.handlePanning, passiveOption);\n    window.addEventListener(\"mouseup\", this.handleStopPanning, passiveOption);\n  };\n\n  StateProvider.prototype.componentWillUnmount = function () {\n    var passiveOption = makePassiveEventOption(false);\n    window.removeEventListener(\"mousedown\", this.handleStartPanning, passiveOption);\n    window.removeEventListener(\"mousemove\", this.handlePanning, passiveOption);\n    window.removeEventListener(\"mouseup\", this.handleStopPanning, passiveOption);\n    handleDisableAnimation.call(this);\n  };\n\n  StateProvider.prototype.componentDidUpdate = function (oldProps, oldState) {\n    var _a = this.state,\n        wrapperComponent = _a.wrapperComponent,\n        contentComponent = _a.contentComponent;\n    var dynamicValues = this.props.dynamicValues;\n\n    if (!oldState.contentComponent && contentComponent) {\n      this.stateProvider.contentComponent = contentComponent;\n    }\n\n    if (!oldState.wrapperComponent && wrapperComponent && wrapperComponent !== undefined) {\n      this.stateProvider.wrapperComponent = wrapperComponent;\n      this.windowToWrapperScaleX = getWindowScaleX(wrapperComponent);\n      this.windowToWrapperScaleY = getWindowScaleY(wrapperComponent); // Zooming events on wrapper\n\n      var passiveOption = makePassiveEventOption(false);\n      wrapperComponent.addEventListener(\"wheel\", this.handleWheel, passiveOption);\n      wrapperComponent.addEventListener(\"dblclick\", this.handleDbClick, passiveOption);\n      wrapperComponent.addEventListener(\"touchstart\", this.handleTouchStart, passiveOption);\n      wrapperComponent.addEventListener(\"touchmove\", this.handleTouch, passiveOption);\n      wrapperComponent.addEventListener(\"touchend\", this.handleTouchStop, passiveOption);\n    } // set bound for animations\n\n\n    if (wrapperComponent && contentComponent || oldProps.dynamicValues !== dynamicValues) {\n      this.maxBounds = handleCalculateBounds.call(this, this.stateProvider.scale, this.stateProvider.options.limitToWrapper);\n    } // must be at the end of the update function, updates\n\n\n    if (oldProps.dynamicValues && oldProps.dynamicValues !== dynamicValues) {\n      this.animation = null;\n      this.stateProvider = _assign(_assign({}, this.stateProvider), mergeProps(this.stateProvider, dynamicValues));\n      this.applyTransformation(null, null, null);\n    }\n  };\n\n  StateProvider.prototype.render = function () {\n    var _a = this.state,\n        wrapperComponent = _a.wrapperComponent,\n        contentComponent = _a.contentComponent;\n    /**\r\n     * Context provider value\r\n     */\n\n    var value = {\n      loaded: Boolean(wrapperComponent && contentComponent),\n      state: this.getCallbackProps(),\n      dispatch: {\n        setScale: this.setScale,\n        setPositionX: this.setPositionX,\n        setPositionY: this.setPositionY,\n        zoomIn: this.zoomIn,\n        zoomOut: this.zoomOut,\n        setTransform: this.setTransform,\n        resetTransform: this.resetTransform,\n        setDefaultState: this.setDefaultState\n      },\n      nodes: {\n        setWrapperComponent: this.setWrapperComponent,\n        setContentComponent: this.setContentComponent\n      }\n    };\n    var children = this.props.children;\n    var content = typeof children === \"function\" ? children(_assign(_assign({}, value.state), value.dispatch)) : children;\n    return React.createElement(Context.Provider, {\n      value: value\n    }, content);\n  };\n\n  return StateProvider;\n}(Component);\n\nvar TransformWrapper = function TransformWrapper(_a) {\n  var children = _a.children,\n      defaultPositionX = _a.defaultPositionX,\n      defaultPositionY = _a.defaultPositionY,\n      defaultScale = _a.defaultScale,\n      onWheelStart = _a.onWheelStart,\n      onWheel = _a.onWheel,\n      onWheelStop = _a.onWheelStop,\n      onPanningStart = _a.onPanningStart,\n      onPanning = _a.onPanning,\n      onPanningStop = _a.onPanningStop,\n      onPinchingStart = _a.onPinchingStart,\n      onPinching = _a.onPinching,\n      onPinchingStop = _a.onPinchingStop,\n      onZoomChange = _a.onZoomChange,\n      rest = __rest(_a, [\"children\", \"defaultPositionX\", \"defaultPositionY\", \"defaultScale\", \"onWheelStart\", \"onWheel\", \"onWheelStop\", \"onPanningStart\", \"onPanning\", \"onPanningStop\", \"onPinchingStart\", \"onPinching\", \"onPinchingStop\", \"onZoomChange\"]);\n\n  var props = _assign({}, rest);\n\n  if (props.options && props.options.limitToWrapper) {\n    props.options.limitToBounds = true;\n  }\n\n  return React.createElement(StateProvider, {\n    defaultValues: deleteUndefinedProps({\n      positionX: defaultPositionX,\n      positionY: defaultPositionY,\n      scale: defaultScale\n    }),\n    dynamicValues: deleteUndefinedProps(getValidPropsFromObject(props)),\n    onWheelStart: onWheelStart,\n    onWheel: onWheel,\n    onWheelStop: onWheelStop,\n    onPanningStart: onPanningStart,\n    onPanning: onPanning,\n    onPanningStop: onPanningStop,\n    onPinchingStart: onPinchingStart,\n    onPinching: onPinching,\n    onPinchingStop: onPinchingStop,\n    onZoomChange: onZoomChange\n  }, children);\n};\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".TransformComponent-module_container__3NwNd {\\n  position: relative;\\n  width: fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.TransformComponent-module_content__TZU5O {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.TransformComponent-module_content__TZU5O img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\n  \"container\": \"TransformComponent-module_container__3NwNd\",\n  \"content\": \"TransformComponent-module_content__TZU5O\"\n};\nstyleInject(css);\n\nvar TransformComponent =\n/** @class */\nfunction (_super) {\n  __extends(TransformComponent, _super);\n\n  function TransformComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.wrapperRef = React.createRef();\n    _this.contentRef = React.createRef();\n    return _this;\n  }\n\n  TransformComponent.prototype.componentDidMount = function () {\n    var nodes = this.context.nodes;\n    nodes.setWrapperComponent(this.wrapperRef.current);\n    nodes.setContentComponent(this.contentRef.current);\n  };\n\n  TransformComponent.prototype.render = function () {\n    var children = this.props.children;\n    var _a = this.context.state,\n        positionX = _a.positionX,\n        positionY = _a.positionY,\n        scale = _a.scale,\n        _b = _a.options,\n        wrapperClass = _b.wrapperClass,\n        contentClass = _b.contentClass;\n    var style = {\n      WebkitTransform: \"translate(\" + positionX + \"px, \" + positionY + \"px) scale(\" + scale + \")\",\n      transform: \"translate(\" + positionX + \"px, \" + positionY + \"px) scale(\" + scale + \")\"\n    };\n    return React.createElement(\"div\", {\n      ref: this.wrapperRef,\n      className: \"react-transform-component \" + styles.container + \" \" + wrapperClass\n    }, React.createElement(\"div\", {\n      ref: this.contentRef,\n      className: \"react-transform-element \" + styles.content + \" \" + contentClass,\n      style: style\n    }, children));\n  };\n\n  return TransformComponent;\n}(React.Component);\n\nTransformComponent.contextType = Context;\nexport { TransformComponent, TransformWrapper };","map":null,"metadata":{},"sourceType":"module"}